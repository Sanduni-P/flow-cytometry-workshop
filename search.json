[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Flow Cytometry Analysis using R - cytoverse",
    "section": "",
    "text": "The cytoverse is a collection of open source R based tools developed by the founders of Ozette Technologies which facilitate programmatic analysis of flow cytometry data.\nA number of packages make up the cytoverse. flowCore, flowWorkspace, openCyto, and ggcyto make up the core of the cytoverse. These packages are, by and large, powerful and sufficient to create robust and reproducible analysis workflows for flow cytometry data. Additional available packages such as flowClust, flowStats, CytoQC, or CytoML can be further utilized for niche applications including, model based clustering of flow cytometry data, QC and standardization of set of FCS files, even parsing of workspaces from FlowJo or cytobank.\n\n\nThe aim of this workshop is to empower flow cytometry users and analysts towards reproducible and programmatic analysis.\nBy the end of this workshop, the attendees will be able to\n\nImport flow cytometry data\nUnderstand the difference between uncompensated, compensated, and transformed data,\nIdentify sub-populations by manual or semi-automated gating of markers,\nAccess and extract expression matrix from a gated data,\nBe aware of csv-templating of Gating to perform large-scale gating\nIdentify and generate important plots to assess the data and quality,\nGenerate plots summarizing the expression of markers and abundance of various sub-populations\n\n\n\n\n\n\n\nActivity\nTime\n\n\n\n\nIntroduction and use of docker container\n– minutes\n\n\nBasics of working with FCS files\n30 minutes\n\n\nSpillover, Transformation\n25 minutes\n\n\nGating Cells in the cytoverse\n40 minutes\n\n\nVisualization using ggcyto\n– minutes\n\n\nReporting\n– minutes\n\n\nWrap-up\n10 minutes\n\n\n\n\n\n\n\nSome R knowledge\nBasic flow cytometry knowledge\n\n\n\n\nFor this workshop, we will use subset of a public data set: FR-FCM-Z5PC that can be found in flowrepository.org. The dataset was published in the following paper."
  },
  {
    "objectID": "index.html#learning-goals",
    "href": "index.html#learning-goals",
    "title": "Flow Cytometry Analysis using R - cytoverse",
    "section": "",
    "text": "The aim of this workshop is to empower flow cytometry users and analysts towards reproducible and programmatic analysis.\nBy the end of this workshop, the attendees will be able to\n\nImport flow cytometry data\nUnderstand the difference between uncompensated, compensated, and transformed data,\nIdentify sub-populations by manual or semi-automated gating of markers,\nAccess and extract expression matrix from a gated data,\nBe aware of csv-templating of Gating to perform large-scale gating\nIdentify and generate important plots to assess the data and quality,\nGenerate plots summarizing the expression of markers and abundance of various sub-populations"
  },
  {
    "objectID": "index.html#workshop-schedule",
    "href": "index.html#workshop-schedule",
    "title": "Flow Cytometry Analysis using R - cytoverse",
    "section": "",
    "text": "Activity\nTime\n\n\n\n\nIntroduction and use of docker container\n– minutes\n\n\nBasics of working with FCS files\n30 minutes\n\n\nSpillover, Transformation\n25 minutes\n\n\nGating Cells in the cytoverse\n40 minutes\n\n\nVisualization using ggcyto\n– minutes\n\n\nReporting\n– minutes\n\n\nWrap-up\n10 minutes"
  },
  {
    "objectID": "index.html#prerequisitesassumptions",
    "href": "index.html#prerequisitesassumptions",
    "title": "Flow Cytometry Analysis using R - cytoverse",
    "section": "",
    "text": "Some R knowledge\nBasic flow cytometry knowledge"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Flow Cytometry Analysis using R - cytoverse",
    "section": "",
    "text": "For this workshop, we will use subset of a public data set: FR-FCM-Z5PC that can be found in flowrepository.org. The dataset was published in the following paper."
  },
  {
    "objectID": "vignettes/6_ggcyto.html",
    "href": "vignettes/6_ggcyto.html",
    "title": "Visualizations using ggcyto",
    "section": "",
    "text": "We have spent a bit of time going over import, manupulation, compensation, and transformation of flow cytometry data. Importantly, we have used visualizations to highlight the importance of various steps. Here, we dedicate some time to visualization of flow cytometry data using ggcyto library from the cytoverse\nFor those who have experience working with ggplot, the approach is going to be similar. As such, ggcyto provides a easy to use yet powerful approach to visualize flow cytometry data.\nIt is also important to note that ggcyto works with each of cytoframe, cytoset, GatingSet, and GatingHierarchy and allows the user to utilize various attributes of each of the object. For instance, metadata within a cytoset and GatingSet can be used to prepare insightful visualizations, rapidly.\n\nlibrary(flowCore)\nlibrary(ggcyto)\n\nFirst, extract a cytoframe from the richly gated GatingSet we worked in Gating cells in cytoverse. Shortly we’ll also see how to work with the GatingSet itself.\n\nsource(\"make_transformed_gs_func.R\")\ngs &lt;- make_transformed_gs(add_gates = TRUE)\ncf &lt;- gh_pop_get_data(gs[[1]],\"root\")\n\n\n\nThe autoplot method is convenient for rapid generation of plots with minimal effort.\n\nBivariate plot\n\n\n# cytoframe: bivariate plot\nautoplot(cf,\n         x = \"CD4\", # markername in human readable format\n         y = \"R730-A\", # markername as colname of flowFrame \n         bins = 256)\n\n\n\n\n\nDensity plot\n\n\n# cytoframe: density plot\nautoplot(cf,\n         x = \"CD4\")+ # y not results in a density plot\n         geom_density() # utilize ggplot geom\n\n\n\n\n\nBivariate plot of the entire GatingHeirarchy\n\n\n# GatingSet: full GatingHierachy\nautoplot(gs[[2]], # single GatingHierachy will plot the entire gating path\n        bins = 256)+ # bins control resolution\n        ggcyto_par_set(limits = \"data\")+ # axis limits based on data \n        geom_stats(type = c(\"gate_name\",\"percent\")) # add name of gate and statistic\n\n\n\n\n\nSpecific node within a GatingSet\n\n\n# GatingSet: single gate\nautoplot(gs,\n         gate = \"CD3+ T cells\", # plot a specific gate for all samples \n         bins = 256)+\n         ggcyto_par_set(limits = \"data\")+\n         axis_x_inverse_trans()+ # inverse transform the axes\n         axis_y_inverse_trans()\n\n\n\n\nNote: When working with GatingSet or GatingHierarchy, the autoplot method does not take x and y parameters. Rather either a gate can be specified or if left unspecified, the entire GatingHierachy is plotted.\n\n\n\nThe ggcyto method takes us 1 step deeper into granular control when visualizing cytometry data. Using this method, users can now start to make visualizations not afforded by autoplot.\n\nBivariate plot for data within a specific node using markers other than those defined for a node\n\n\nggcyto(gs,\n       subset = \"singlet\", # extract data at specific node\n       aes(x = \"CD8a\", y = \"CD4\"))+ # any marker combination \n  geom_hex(bins = 256)+\n  facet_wrap(~name)\n\n\n\n\nThe marker combination “CD8a vs CD4” is used to at the node /singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells to define CD4+ vs CD8+ T cells. Unlike with autoplot, ggcyto method allows us to look at the data from the point of subset. In the above example, subset = \"singlet\".\n\n\n\nRepeat the previous plot, but facet_wrap upon another variable.\n\n\nDuring reporting, it is possible that users would want to see\n\n# get a gate\ncd4_gate &lt;- gs_pop_get_gate(gs,\"CD4+CD8a-\")\n\nggcyto(gs,\n       subset = \"singlet\", # extract data at specific node\n       aes(x = \"CD8a\", y = \"CD4\"))+ # any marker combination \n  geom_hex(bins = 256)+\n  facet_wrap(~name)+\n  geom_gate(cd4_gate)+ # plot gate\n  geom_stats(type = \"percent\")+ # on the fly calculation of the \"gate\" event\n  axis_x_inverse_trans()+\n  axis_y_inverse_trans()\n\n\n\n\n\n\n\n\nRepeat the above plot but now set the parent subset to be the \"not_MAIT_polygon\". Why does your plot look different than the previous one?\n\nAnswer: The singlet/CD4+CD8a- population that in effect we were visualizing, was not defined in the GatingSet; instead the parent node to CD4+CD8a- is non-MAIT conventional T cells (/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/). This ad hoc visualization tells us that CD4+ cells (not sure at this point if they are CD3+ T cells) are ~47% of total singlet population that we had defined.\n\n\nIn a similar manner, we can use a newly defined gate to interrogate the GatingSet.\n\nnew_gate &lt;- flowCore::rectangleGate(\n  list(\"V570-A\" = c(150,210),\n       \"V510-A\" = c(140,210)),\n  filterId = \"CD3+CD8a+ Cells\"\n)\nggcyto(gs,\n       subset = \"singlet\", # extract data at specific node\n       aes(x = \"CD3\", y = \"CD8a\"))+ # any marker combination \n  geom_hex(bins = 256)+\n  facet_grid(mock_treatment~name)+ # facet according to treatment\n  geom_gate(new_gate)+\n  ggcyto_par_set(limits = \"data\")+\n  geom_stats(type = \"percent\")+\n  axis_x_inverse_trans()+\n  axis_y_inverse_trans()\n\n\n\n\nWe created a gate, did not apply it to a GatingSet directly, but rather made an ad hoc plot regarding CD8a+ CD3+ T cells from the singlet node. This plot also shows how metadata from pData is available to facet the plot.\n\n\n\n\nA common way to report or view specific population data is to ask whether there is a change in expression levels (fluorescence intensity) across samples or groups.\nLet’s take a look at PD1 expression in CD8+ T Cells\n\ncd8 &lt;- as.ggplot(ggcyto(gs,\n       subset = \"CD4-CD8a+\",\n       aes(x = \"PD1\"))+\n  geom_histogram(bins = 125, fill = \"yellow\", color = \"black\")+\n  facet_wrap(name~mock_treatment,ncol = 1, scales = \"free_y\")+\n  ggcyto::labs_cyto(labels = \"marker\")) # labeling only marker\ncd8\n\n\n\n\nWhat if you would like to compare 2 different populations side by side?\n\ncd4 &lt;- as.ggplot(ggcyto(gs,\n              subset = \"CD4+CD8a-\",\n              aes(x = \"PD1\"))+\n  geom_histogram(bins = 125, fill = \"blue\", colour = \"black\")+\n  facet_wrap(name~mock_treatment,ncol = 1, scales = \"free_y\")+\n  ggcyto::labs_cyto(labels = \"marker\")) # labeling only marker\n\ngridExtra::grid.arrange(cd4,cd8, ncol =2 )\n\n\n\n\nOr, if you would like to compare population on top of each other?\n\noverlay &lt;-ggcyto(gs,\n                  subset = \"CD4+CD8a-\",\n                  aes(x = \"PD1\"))+\n  geom_density(fill = \"red\", alpha = 0.3)+\n  geom_overlay(\n    data = gs_pop_get_data(gs,\"MAIT Cells\"), # extracting information regarding a different population\n    fill = \"black\", alpha = 0.5)+\n  axis_x_inverse_trans()+\n  labs(title = \"Comparing expression of PD1 in 2 distinct T cells: CD8a+ (red) and CD161+ Va7_2+ MAIT Cells (black)\")+\n  facet_wrap(mock_treatment~name, nrow = 1)+\n  theme(aspect.ratio = 1)\noverlay\n\n\n\n\nSeems like MAIT Cells tend to have higher PD1 expression than CD8+ T Cells! This may be an interesting observation that is worth following up on.\n\n\n\nThere are instances when you may want to visualize a gated population (children/grandchildren/siblings) together with the parent. This is the idea behind backgating. We have already seen met this approach above using geom_overlay where density of 1 node was projected on top of density of a different unrelated node.\nBelow, we go through another example where we ask the question: what is the general expression level of CD4 and CD8a on MAIT cells compared to all CD3+ T cells?\n\nmait_expression &lt;- ggcyto(gs,\n                          subset = \"CD3+ T cells\",\n                          aes(x = \"CD4\", y = \"CD8a\"))+\n                   geom_hex(bins = 256)+\n                   geom_overlay(data = \n                                  gs_pop_get_data(gs, \"MAIT Cells\"),\n                                size = 0.5, colour = \"red\", alpha = 0.5)+\n                   axis_x_inverse_trans()+\n                   axis_y_inverse_trans()+\n                   facet_wrap(~name, nrow = 1)+\n  labs(title = \"MAIT Cells (red) overlaid on top of all conventional T Cells\")+\n  theme(aspect.ratio = 1)\nmait_expression  \n\n\n\n\nSeems like there are a lot of MAIT Cells that are CD8a+ or negative for both CD8a and CD4 compared to CD4+.\n\n\n\nPrepare an overlay as above using the autoplot method.\n\nHint:\n\n\nexample &lt;- autoplot(\n  # add your code\n  axis_inverse_transform = TRUE,\n  bins = 256\n)+\n  geom_overlay(\n    gs_pop_get_data(gs, \"MAIT Cells\"),\n    size = 0.5,\n    colour = \"red\"\n  )\n\n\n\nConstruct a rectangleGate for CD8+ cells and add it to the plot you create.\nWhy are the scales not inverse transformed?"
  },
  {
    "objectID": "vignettes/6_ggcyto.html#hit-the-ground-running-using-autoplot",
    "href": "vignettes/6_ggcyto.html#hit-the-ground-running-using-autoplot",
    "title": "Visualizations using ggcyto",
    "section": "",
    "text": "The autoplot method is convenient for rapid generation of plots with minimal effort.\n\nBivariate plot\n\n\n# cytoframe: bivariate plot\nautoplot(cf,\n         x = \"CD4\", # markername in human readable format\n         y = \"R730-A\", # markername as colname of flowFrame \n         bins = 256)\n\n\n\n\n\nDensity plot\n\n\n# cytoframe: density plot\nautoplot(cf,\n         x = \"CD4\")+ # y not results in a density plot\n         geom_density() # utilize ggplot geom\n\n\n\n\n\nBivariate plot of the entire GatingHeirarchy\n\n\n# GatingSet: full GatingHierachy\nautoplot(gs[[2]], # single GatingHierachy will plot the entire gating path\n        bins = 256)+ # bins control resolution\n        ggcyto_par_set(limits = \"data\")+ # axis limits based on data \n        geom_stats(type = c(\"gate_name\",\"percent\")) # add name of gate and statistic\n\n\n\n\n\nSpecific node within a GatingSet\n\n\n# GatingSet: single gate\nautoplot(gs,\n         gate = \"CD3+ T cells\", # plot a specific gate for all samples \n         bins = 256)+\n         ggcyto_par_set(limits = \"data\")+\n         axis_x_inverse_trans()+ # inverse transform the axes\n         axis_y_inverse_trans()\n\n\n\n\nNote: When working with GatingSet or GatingHierarchy, the autoplot method does not take x and y parameters. Rather either a gate can be specified or if left unspecified, the entire GatingHierachy is plotted."
  },
  {
    "objectID": "vignettes/6_ggcyto.html#granular-control-using-ggcyto",
    "href": "vignettes/6_ggcyto.html#granular-control-using-ggcyto",
    "title": "Visualizations using ggcyto",
    "section": "",
    "text": "The ggcyto method takes us 1 step deeper into granular control when visualizing cytometry data. Using this method, users can now start to make visualizations not afforded by autoplot.\n\nBivariate plot for data within a specific node using markers other than those defined for a node\n\n\nggcyto(gs,\n       subset = \"singlet\", # extract data at specific node\n       aes(x = \"CD8a\", y = \"CD4\"))+ # any marker combination \n  geom_hex(bins = 256)+\n  facet_wrap(~name)\n\n\n\n\nThe marker combination “CD8a vs CD4” is used to at the node /singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells to define CD4+ vs CD8+ T cells. Unlike with autoplot, ggcyto method allows us to look at the data from the point of subset. In the above example, subset = \"singlet\".\n\n\n\nRepeat the previous plot, but facet_wrap upon another variable.\n\n\nDuring reporting, it is possible that users would want to see\n\n# get a gate\ncd4_gate &lt;- gs_pop_get_gate(gs,\"CD4+CD8a-\")\n\nggcyto(gs,\n       subset = \"singlet\", # extract data at specific node\n       aes(x = \"CD8a\", y = \"CD4\"))+ # any marker combination \n  geom_hex(bins = 256)+\n  facet_wrap(~name)+\n  geom_gate(cd4_gate)+ # plot gate\n  geom_stats(type = \"percent\")+ # on the fly calculation of the \"gate\" event\n  axis_x_inverse_trans()+\n  axis_y_inverse_trans()\n\n\n\n\n\n\n\n\nRepeat the above plot but now set the parent subset to be the \"not_MAIT_polygon\". Why does your plot look different than the previous one?\n\nAnswer: The singlet/CD4+CD8a- population that in effect we were visualizing, was not defined in the GatingSet; instead the parent node to CD4+CD8a- is non-MAIT conventional T cells (/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/). This ad hoc visualization tells us that CD4+ cells (not sure at this point if they are CD3+ T cells) are ~47% of total singlet population that we had defined.\n\n\nIn a similar manner, we can use a newly defined gate to interrogate the GatingSet.\n\nnew_gate &lt;- flowCore::rectangleGate(\n  list(\"V570-A\" = c(150,210),\n       \"V510-A\" = c(140,210)),\n  filterId = \"CD3+CD8a+ Cells\"\n)\nggcyto(gs,\n       subset = \"singlet\", # extract data at specific node\n       aes(x = \"CD3\", y = \"CD8a\"))+ # any marker combination \n  geom_hex(bins = 256)+\n  facet_grid(mock_treatment~name)+ # facet according to treatment\n  geom_gate(new_gate)+\n  ggcyto_par_set(limits = \"data\")+\n  geom_stats(type = \"percent\")+\n  axis_x_inverse_trans()+\n  axis_y_inverse_trans()\n\n\n\n\nWe created a gate, did not apply it to a GatingSet directly, but rather made an ad hoc plot regarding CD8a+ CD3+ T cells from the singlet node. This plot also shows how metadata from pData is available to facet the plot."
  },
  {
    "objectID": "vignettes/6_ggcyto.html#expression-using-histograms-and-densities",
    "href": "vignettes/6_ggcyto.html#expression-using-histograms-and-densities",
    "title": "Visualizations using ggcyto",
    "section": "",
    "text": "A common way to report or view specific population data is to ask whether there is a change in expression levels (fluorescence intensity) across samples or groups.\nLet’s take a look at PD1 expression in CD8+ T Cells\n\ncd8 &lt;- as.ggplot(ggcyto(gs,\n       subset = \"CD4-CD8a+\",\n       aes(x = \"PD1\"))+\n  geom_histogram(bins = 125, fill = \"yellow\", color = \"black\")+\n  facet_wrap(name~mock_treatment,ncol = 1, scales = \"free_y\")+\n  ggcyto::labs_cyto(labels = \"marker\")) # labeling only marker\ncd8\n\n\n\n\nWhat if you would like to compare 2 different populations side by side?\n\ncd4 &lt;- as.ggplot(ggcyto(gs,\n              subset = \"CD4+CD8a-\",\n              aes(x = \"PD1\"))+\n  geom_histogram(bins = 125, fill = \"blue\", colour = \"black\")+\n  facet_wrap(name~mock_treatment,ncol = 1, scales = \"free_y\")+\n  ggcyto::labs_cyto(labels = \"marker\")) # labeling only marker\n\ngridExtra::grid.arrange(cd4,cd8, ncol =2 )\n\n\n\n\nOr, if you would like to compare population on top of each other?\n\noverlay &lt;-ggcyto(gs,\n                  subset = \"CD4+CD8a-\",\n                  aes(x = \"PD1\"))+\n  geom_density(fill = \"red\", alpha = 0.3)+\n  geom_overlay(\n    data = gs_pop_get_data(gs,\"MAIT Cells\"), # extracting information regarding a different population\n    fill = \"black\", alpha = 0.5)+\n  axis_x_inverse_trans()+\n  labs(title = \"Comparing expression of PD1 in 2 distinct T cells: CD8a+ (red) and CD161+ Va7_2+ MAIT Cells (black)\")+\n  facet_wrap(mock_treatment~name, nrow = 1)+\n  theme(aspect.ratio = 1)\noverlay\n\n\n\n\nSeems like MAIT Cells tend to have higher PD1 expression than CD8+ T Cells! This may be an interesting observation that is worth following up on."
  },
  {
    "objectID": "vignettes/6_ggcyto.html#backgating-and-overlays",
    "href": "vignettes/6_ggcyto.html#backgating-and-overlays",
    "title": "Visualizations using ggcyto",
    "section": "",
    "text": "There are instances when you may want to visualize a gated population (children/grandchildren/siblings) together with the parent. This is the idea behind backgating. We have already seen met this approach above using geom_overlay where density of 1 node was projected on top of density of a different unrelated node.\nBelow, we go through another example where we ask the question: what is the general expression level of CD4 and CD8a on MAIT cells compared to all CD3+ T cells?\n\nmait_expression &lt;- ggcyto(gs,\n                          subset = \"CD3+ T cells\",\n                          aes(x = \"CD4\", y = \"CD8a\"))+\n                   geom_hex(bins = 256)+\n                   geom_overlay(data = \n                                  gs_pop_get_data(gs, \"MAIT Cells\"),\n                                size = 0.5, colour = \"red\", alpha = 0.5)+\n                   axis_x_inverse_trans()+\n                   axis_y_inverse_trans()+\n                   facet_wrap(~name, nrow = 1)+\n  labs(title = \"MAIT Cells (red) overlaid on top of all conventional T Cells\")+\n  theme(aspect.ratio = 1)\nmait_expression  \n\n\n\n\nSeems like there are a lot of MAIT Cells that are CD8a+ or negative for both CD8a and CD4 compared to CD4+.\n\n\n\nPrepare an overlay as above using the autoplot method.\n\nHint:\n\n\nexample &lt;- autoplot(\n  # add your code\n  axis_inverse_transform = TRUE,\n  bins = 256\n)+\n  geom_overlay(\n    gs_pop_get_data(gs, \"MAIT Cells\"),\n    size = 0.5,\n    colour = \"red\"\n  )\n\n\n\nConstruct a rectangleGate for CD8+ cells and add it to the plot you create.\nWhy are the scales not inverse transformed?"
  },
  {
    "objectID": "vignettes/7_Reporting.html",
    "href": "vignettes/7_Reporting.html",
    "title": "Reporting: Counts, Frequency, etc",
    "section": "",
    "text": "The final step in the analysis of flow cytometry data is Reporting. Below, we show how we can quickly extract counts, frequencies, and expression values for their population(s) of interest.\n\nlibrary(flowCore)\nlibrary(flowWorkspace)\nlibrary(ggcyto)\n\n\n\nWe can easily extract Counts and Frequencies of the gated cell population from the GatingSet.\n\n# get count for all\ncounts &lt;- gs_pop_get_count_fast(gs,  # indicate which GatingSet to use\n                                statistic = \"count\", # indicate what statistic is requested\n                                format = \"wide\") # indicate if data should be in wide (samples are columns) or long (each node for each sample gets a row) format\n\nknitr::kable(head(counts,20), caption = \"Event counts\")\n\n\nEvent counts\n\n\n\n\n\n\n\n\n\n\n4000_TNK-CR1\n4001_TNK-CR1\n4002_TNK-CR1\n4003_TNK-CR1\n\n\n\n\n/singlet\n90201\n82095\n334739\n128359\n\n\n/singlet/live\n85691\n77990\n318002\n121941\n\n\n/singlet/live/lymphocytes\n79632\n72217\n290836\n113559\n\n\n/singlet/live/lymphocytes/CD3+ T cells\n67477\n57833\n241125\n80699\n\n\n/singlet/live/lymphocytes/CD3+ T cells/NKT cells\n5\n112\n477\n75\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells\n64774\n55223\n237368\n80040\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells\n61996\n52005\n228635\n78791\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\n461\n738\n1649\n640\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\n61535\n51267\n226986\n78151\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon\n61578\n51270\n226928\n78154\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\n333\n79\n343\n99\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\n39884\n35776\n138031\n56808\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\n20283\n14674\n85356\n20771\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a-\n1078\n741\n3198\n476\n\n\nroot\n102015\n92703\n372224\n146150\n\n\n\n\n\nChanging statistic to freq return frequency of the gated population with respect to the parent population.\n\nfreq &lt;- gs_pop_get_count_fast(gs,\n                              statistic = \"freq\",\n                              format = \"wide\")\nknitr::kable(head(freq,20), caption = \"Event frequencies relative to parent node\")\n\n\nEvent frequencies relative to parent node\n\n\n\n\n\n\n\n\n\n\n4000_TNK-CR1\n4001_TNK-CR1\n4002_TNK-CR1\n4003_TNK-CR1\n\n\n\n\n/singlet\n0.8841935\n0.8855700\n0.8992945\n0.8782689\n\n\n/singlet/live\n0.9500006\n0.9499970\n0.9499999\n0.9499996\n\n\n/singlet/live/lymphocytes\n0.9292925\n0.9259777\n0.9145729\n0.9312618\n\n\n/singlet/live/lymphocytes/CD3+ T cells\n0.8473604\n0.8008225\n0.8290755\n0.7106350\n\n\n/singlet/live/lymphocytes/CD3+ T cells/NKT cells\n0.0000741\n0.0019366\n0.0019782\n0.0009294\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells\n0.9599419\n0.9548701\n0.9844189\n0.9918339\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells\n0.9571124\n0.9417272\n0.9632090\n0.9843953\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\n0.0074360\n0.0141909\n0.0072124\n0.0081228\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\n0.9925640\n0.9858091\n0.9927876\n0.9918772\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon\n0.9932576\n0.9858667\n0.9925340\n0.9919153\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\n0.0054078\n0.0015409\n0.0015115\n0.0012667\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\n0.6476989\n0.6977960\n0.6082590\n0.7268726\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\n0.3293871\n0.2862103\n0.3761369\n0.2657701\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a-\n0.0175063\n0.0144529\n0.0140926\n0.0060905\n\n\nroot\n1.0000000\n1.0000000\n1.0000000\n1.0000000\n\n\n\n\n\nWhat if one wants to report frequencies relative to a different population?\n\nplot(gs, bool = TRUE)\n\n\n\n\nLet’s consider the scenario here: you would like to calculate the frequency of MAIT Cells, and True_NKT Cells relative to total CD3+ Cells.\nWe can easily achieve this by using gs_pop_get_stats and indicating which node(s) we want\n\nlibrary(magrittr)\n# get count for specified nodes and make wider \npop_counts &lt;- gs_pop_get_stats(gs,\n                                    node = c(\"CD3+ T cells\",\"MAIT Cells\", \"NKT cells\"),\n                                    type = \"count\"\n                                    ) %&gt;% # output is a long column\n  tidyr::pivot_wider(names_from = pop, \n                     values_from = count,names_prefix = \"count_\") %&gt;% # convert to wide\n  dplyr::mutate(MAIT_freq = `count_MAIT Cells`/`count_CD3+ T cells`,\n         NKT_freq = `count_NKT cells`/`count_CD3+ T cells`)\n\n\nknitr::kable(pop_counts,caption = \"Frequency of MAIT and NKT Cells (relative to CD3+ T Cells)\")\n\n\nFrequency of MAIT and NKT Cells (relative to CD3+ T Cells)\n\n\n\n\n\n\n\n\n\n\nsample\ncount_CD3+ T cells\ncount_MAIT Cells\ncount_NKT cells\nMAIT_freq\nNKT_freq\n\n\n\n\n4000_TNK-CR1\n67477\n461\n5\n0.0068320\n0.0000741\n\n\n4001_TNK-CR1\n57833\n738\n112\n0.0127609\n0.0019366\n\n\n4002_TNK-CR1\n241125\n1649\n477\n0.0068388\n0.0019782\n\n\n4003_TNK-CR1\n80699\n640\n75\n0.0079307\n0.0009294\n\n\n\n\n\nAnother common statistic that is reported if MFI (median fluorescence intensity). To extract MFI, we can again make use of gs_pop_get_stat. It is important to realize that MFI is often reported in raw/linear scale.\n\nmfi_dataframe &lt;- gs_pop_get_stats(gs,\n                 nodes = c(\"CD3+ T cells\", \"MAIT Cells\", \"CD4+CD8a-\", \"CD4-CD8a+\"),\n                 type = pop.MFI,\n                 inverse.transform = TRUE)\n\nmfi_dataframe[1:5, 1:5]\n\n         sample          pop TCR Vd1 FITC CD127 BB630 PD1 BB660\n1: 4000_TNK-CR1 CD3+ T cells     255.0227   1072.3564  142.1997\n2: 4000_TNK-CR1   MAIT Cells     273.8928   2158.7324  557.8886\n3: 4000_TNK-CR1    CD4+CD8a-     243.4144   1254.2268  139.9552\n4: 4000_TNK-CR1    CD4-CD8a+     266.7055    856.4607  121.5325\n5: 4001_TNK-CR1 CD3+ T cells     227.1721    626.4796  133.4854\n\n\nFor convenience, MFI are extracted for all markers for each of the specified population.\n\n\n\nIn the table above, we noticed that expression of PD1 is higher in MAIT Cells. Below, we create 2 plots to help drive this point (if this is of interest). We will make use of ggcyto and ggplot2\n\n\n\n# plot some data\npd1_mfi_plot &lt;- dplyr::left_join(pData(gs),mfi_dataframe, \n          by = c(\"name\" = \"sample\")) %&gt;% \n  ggplot(aes(x = mock_treatment, y = `PD1 BB660`, fill = pop))+\n  geom_boxplot()+\n  labs(x = \"Cell Type\", y = \"median PD1 expression\")+\n  scale_fill_manual(values = c(\"CD3+ T cells\" = \"black\",\n                               \"MAIT Cells\" = \"red\",\n                               \"CD4+CD8a-\" = \"blue\",\n                               \"CD4-CD8a+\" = \"green\"),\n                    )+\n  theme(aspect.ratio = 1, \n        legend.position = \"right\")\n\npd1_mfi_plot\n\n\n\n\n\n\n\n\npd1_overlay &lt;- ggcyto(gs,\n       subset = \"MAIT Cells\",\n       aes(x = \"PD1\"))+\n  geom_density(fill = \"red\", alpha = 0.3)+ # MAIT Cells in red\n  geom_overlay(\n    data = gs_pop_get_data(gs,\"CD3+ T cells\"),\n    fill = \"black\", alpha = 0.5)+ # CD3+ Cells in black\n   geom_overlay(\n    data = gs_pop_get_data(gs,\"CD4+CD8a-\"),\n    fill = \"blue\", alpha = 0.5)+ # CD4+ T Cells in blue\n   geom_overlay(\n    data = gs_pop_get_data(gs,\"CD4-CD8a+\"),\n    fill = \"green\", alpha = 0.5)+ # CD8+ T Cells in green\n  axis_x_inverse_trans()+\n  facet_wrap(mock_treatment~name, nrow = 1)+\n  labs(title = \"\",x = \"PD1\")+\n  theme(aspect.ratio = 1)\npd1_overlay &lt;- as.ggplot(pd1_overlay)\n\n\n\n\n\ngridExtra::grid.arrange(\n pd1_mfi_plot,\n pd1_overlay,\n nrow = 2,\n left = \"PD1 expression in T cell subsets\"\n)\n\n\n\n\nIt is now clear that the expression of PD1 indeed tends to be higher on MAIT Cells compared to non-MAIT T Cells.\n\n\n\n\n\nIt is also possible to calculate additional statistics for the population of interest. For instance, if you were interested in nth percentile expression of a specific marker you could define a function and use it in gs_pop_get_stats like so:\n\n# define a function\nmy_quantile &lt;- function(fr,percentile,chnl){\n  matched_chnl &lt;- flowCore::getChannelMarker(fr,chnl) # match channel name\n  res &lt;- apply(exprs(fr)[,matched_chnl[[\"name\"]],drop = FALSE], 2, quantile,percentile) # get quantile for specific channel\n  names(res) &lt;- matched_chnl[[\"desc\"]]\n  return(res)\n}\n\n# get stats\nmedian_cd4 &lt;- gs_pop_get_stats(gs,\n                 c(\"lymphocytes\",\"CD3+ T cells\",\"CD4+CD8a-\",\"CD4-CD8a+\"), \n                 type = my_quantile,\n                 inverse.transform = TRUE,\n                 stats.fun.arg = list(percentile = .5,\n                                      chnl = \"cd4\")) \nknitr::kable(median_cd4,caption = \"Median expression of CD4 extracted using user defined function\")\n\n\nMedian expression of CD4 extracted using user defined function\n\n\nsample\npop\nCD4 BUV805\n\n\n\n\n4000_TNK-CR1\nlymphocytes\n1043.205715\n\n\n4000_TNK-CR1\nCD3+ T cells\n1393.012354\n\n\n4000_TNK-CR1\nCD4+CD8a-\n1866.839339\n\n\n4000_TNK-CR1\nCD4-CD8a+\n3.203119\n\n\n4001_TNK-CR1\nlymphocytes\n873.184795\n\n\n4001_TNK-CR1\nCD3+ T cells\n1366.918737\n\n\n4001_TNK-CR1\nCD4+CD8a-\n1805.953805\n\n\n4001_TNK-CR1\nCD4-CD8a+\n4.153675\n\n\n4002_TNK-CR1\nlymphocytes\n328.090372\n\n\n4002_TNK-CR1\nCD3+ T cells\n959.012183\n\n\n4002_TNK-CR1\nCD4+CD8a-\n1401.996476\n\n\n4002_TNK-CR1\nCD4-CD8a+\n-8.668585\n\n\n4003_TNK-CR1\nlymphocytes\n785.155278\n\n\n4003_TNK-CR1\nCD3+ T cells\n1486.741756\n\n\n4003_TNK-CR1\nCD4+CD8a-\n1758.953449\n\n\n4003_TNK-CR1\nCD4-CD8a+\n-9.211168\n\n\n\n\n\nAs we see, we were able to extract median expression of the marker CD4 on 4 different populations. As expected, expression is highest on CD4+ T Cells and lowest on CD8+ T Cells."
  },
  {
    "objectID": "vignettes/7_Reporting.html#counts-frequencies-and-mfi",
    "href": "vignettes/7_Reporting.html#counts-frequencies-and-mfi",
    "title": "Reporting: Counts, Frequency, etc",
    "section": "",
    "text": "We can easily extract Counts and Frequencies of the gated cell population from the GatingSet.\n\n# get count for all\ncounts &lt;- gs_pop_get_count_fast(gs,  # indicate which GatingSet to use\n                                statistic = \"count\", # indicate what statistic is requested\n                                format = \"wide\") # indicate if data should be in wide (samples are columns) or long (each node for each sample gets a row) format\n\nknitr::kable(head(counts,20), caption = \"Event counts\")\n\n\nEvent counts\n\n\n\n\n\n\n\n\n\n\n4000_TNK-CR1\n4001_TNK-CR1\n4002_TNK-CR1\n4003_TNK-CR1\n\n\n\n\n/singlet\n90201\n82095\n334739\n128359\n\n\n/singlet/live\n85691\n77990\n318002\n121941\n\n\n/singlet/live/lymphocytes\n79632\n72217\n290836\n113559\n\n\n/singlet/live/lymphocytes/CD3+ T cells\n67477\n57833\n241125\n80699\n\n\n/singlet/live/lymphocytes/CD3+ T cells/NKT cells\n5\n112\n477\n75\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells\n64774\n55223\n237368\n80040\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells\n61996\n52005\n228635\n78791\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\n461\n738\n1649\n640\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\n61535\n51267\n226986\n78151\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon\n61578\n51270\n226928\n78154\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\n333\n79\n343\n99\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\n39884\n35776\n138031\n56808\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\n20283\n14674\n85356\n20771\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a-\n1078\n741\n3198\n476\n\n\nroot\n102015\n92703\n372224\n146150\n\n\n\n\n\nChanging statistic to freq return frequency of the gated population with respect to the parent population.\n\nfreq &lt;- gs_pop_get_count_fast(gs,\n                              statistic = \"freq\",\n                              format = \"wide\")\nknitr::kable(head(freq,20), caption = \"Event frequencies relative to parent node\")\n\n\nEvent frequencies relative to parent node\n\n\n\n\n\n\n\n\n\n\n4000_TNK-CR1\n4001_TNK-CR1\n4002_TNK-CR1\n4003_TNK-CR1\n\n\n\n\n/singlet\n0.8841935\n0.8855700\n0.8992945\n0.8782689\n\n\n/singlet/live\n0.9500006\n0.9499970\n0.9499999\n0.9499996\n\n\n/singlet/live/lymphocytes\n0.9292925\n0.9259777\n0.9145729\n0.9312618\n\n\n/singlet/live/lymphocytes/CD3+ T cells\n0.8473604\n0.8008225\n0.8290755\n0.7106350\n\n\n/singlet/live/lymphocytes/CD3+ T cells/NKT cells\n0.0000741\n0.0019366\n0.0019782\n0.0009294\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells\n0.9599419\n0.9548701\n0.9844189\n0.9918339\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells\n0.9571124\n0.9417272\n0.9632090\n0.9843953\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\n0.0074360\n0.0141909\n0.0072124\n0.0081228\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\n0.9925640\n0.9858091\n0.9927876\n0.9918772\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon\n0.9932576\n0.9858667\n0.9925340\n0.9919153\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\n0.0054078\n0.0015409\n0.0015115\n0.0012667\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\n0.6476989\n0.6977960\n0.6082590\n0.7268726\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\n0.3293871\n0.2862103\n0.3761369\n0.2657701\n\n\n/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a-\n0.0175063\n0.0144529\n0.0140926\n0.0060905\n\n\nroot\n1.0000000\n1.0000000\n1.0000000\n1.0000000\n\n\n\n\n\nWhat if one wants to report frequencies relative to a different population?\n\nplot(gs, bool = TRUE)\n\n\n\n\nLet’s consider the scenario here: you would like to calculate the frequency of MAIT Cells, and True_NKT Cells relative to total CD3+ Cells.\nWe can easily achieve this by using gs_pop_get_stats and indicating which node(s) we want\n\nlibrary(magrittr)\n# get count for specified nodes and make wider \npop_counts &lt;- gs_pop_get_stats(gs,\n                                    node = c(\"CD3+ T cells\",\"MAIT Cells\", \"NKT cells\"),\n                                    type = \"count\"\n                                    ) %&gt;% # output is a long column\n  tidyr::pivot_wider(names_from = pop, \n                     values_from = count,names_prefix = \"count_\") %&gt;% # convert to wide\n  dplyr::mutate(MAIT_freq = `count_MAIT Cells`/`count_CD3+ T cells`,\n         NKT_freq = `count_NKT cells`/`count_CD3+ T cells`)\n\n\nknitr::kable(pop_counts,caption = \"Frequency of MAIT and NKT Cells (relative to CD3+ T Cells)\")\n\n\nFrequency of MAIT and NKT Cells (relative to CD3+ T Cells)\n\n\n\n\n\n\n\n\n\n\nsample\ncount_CD3+ T cells\ncount_MAIT Cells\ncount_NKT cells\nMAIT_freq\nNKT_freq\n\n\n\n\n4000_TNK-CR1\n67477\n461\n5\n0.0068320\n0.0000741\n\n\n4001_TNK-CR1\n57833\n738\n112\n0.0127609\n0.0019366\n\n\n4002_TNK-CR1\n241125\n1649\n477\n0.0068388\n0.0019782\n\n\n4003_TNK-CR1\n80699\n640\n75\n0.0079307\n0.0009294\n\n\n\n\n\nAnother common statistic that is reported if MFI (median fluorescence intensity). To extract MFI, we can again make use of gs_pop_get_stat. It is important to realize that MFI is often reported in raw/linear scale.\n\nmfi_dataframe &lt;- gs_pop_get_stats(gs,\n                 nodes = c(\"CD3+ T cells\", \"MAIT Cells\", \"CD4+CD8a-\", \"CD4-CD8a+\"),\n                 type = pop.MFI,\n                 inverse.transform = TRUE)\n\nmfi_dataframe[1:5, 1:5]\n\n         sample          pop TCR Vd1 FITC CD127 BB630 PD1 BB660\n1: 4000_TNK-CR1 CD3+ T cells     255.0227   1072.3564  142.1997\n2: 4000_TNK-CR1   MAIT Cells     273.8928   2158.7324  557.8886\n3: 4000_TNK-CR1    CD4+CD8a-     243.4144   1254.2268  139.9552\n4: 4000_TNK-CR1    CD4-CD8a+     266.7055    856.4607  121.5325\n5: 4001_TNK-CR1 CD3+ T cells     227.1721    626.4796  133.4854\n\n\nFor convenience, MFI are extracted for all markers for each of the specified population."
  },
  {
    "objectID": "vignettes/7_Reporting.html#a-simple-report",
    "href": "vignettes/7_Reporting.html#a-simple-report",
    "title": "Reporting: Counts, Frequency, etc",
    "section": "",
    "text": "In the table above, we noticed that expression of PD1 is higher in MAIT Cells. Below, we create 2 plots to help drive this point (if this is of interest). We will make use of ggcyto and ggplot2\n\n\n\n# plot some data\npd1_mfi_plot &lt;- dplyr::left_join(pData(gs),mfi_dataframe, \n          by = c(\"name\" = \"sample\")) %&gt;% \n  ggplot(aes(x = mock_treatment, y = `PD1 BB660`, fill = pop))+\n  geom_boxplot()+\n  labs(x = \"Cell Type\", y = \"median PD1 expression\")+\n  scale_fill_manual(values = c(\"CD3+ T cells\" = \"black\",\n                               \"MAIT Cells\" = \"red\",\n                               \"CD4+CD8a-\" = \"blue\",\n                               \"CD4-CD8a+\" = \"green\"),\n                    )+\n  theme(aspect.ratio = 1, \n        legend.position = \"right\")\n\npd1_mfi_plot\n\n\n\n\n\n\n\n\npd1_overlay &lt;- ggcyto(gs,\n       subset = \"MAIT Cells\",\n       aes(x = \"PD1\"))+\n  geom_density(fill = \"red\", alpha = 0.3)+ # MAIT Cells in red\n  geom_overlay(\n    data = gs_pop_get_data(gs,\"CD3+ T cells\"),\n    fill = \"black\", alpha = 0.5)+ # CD3+ Cells in black\n   geom_overlay(\n    data = gs_pop_get_data(gs,\"CD4+CD8a-\"),\n    fill = \"blue\", alpha = 0.5)+ # CD4+ T Cells in blue\n   geom_overlay(\n    data = gs_pop_get_data(gs,\"CD4-CD8a+\"),\n    fill = \"green\", alpha = 0.5)+ # CD8+ T Cells in green\n  axis_x_inverse_trans()+\n  facet_wrap(mock_treatment~name, nrow = 1)+\n  labs(title = \"\",x = \"PD1\")+\n  theme(aspect.ratio = 1)\npd1_overlay &lt;- as.ggplot(pd1_overlay)\n\n\n\n\n\ngridExtra::grid.arrange(\n pd1_mfi_plot,\n pd1_overlay,\n nrow = 2,\n left = \"PD1 expression in T cell subsets\"\n)\n\n\n\n\nIt is now clear that the expression of PD1 indeed tends to be higher on MAIT Cells compared to non-MAIT T Cells."
  },
  {
    "objectID": "vignettes/7_Reporting.html#optional-additional-statistics",
    "href": "vignettes/7_Reporting.html#optional-additional-statistics",
    "title": "Reporting: Counts, Frequency, etc",
    "section": "",
    "text": "It is also possible to calculate additional statistics for the population of interest. For instance, if you were interested in nth percentile expression of a specific marker you could define a function and use it in gs_pop_get_stats like so:\n\n# define a function\nmy_quantile &lt;- function(fr,percentile,chnl){\n  matched_chnl &lt;- flowCore::getChannelMarker(fr,chnl) # match channel name\n  res &lt;- apply(exprs(fr)[,matched_chnl[[\"name\"]],drop = FALSE], 2, quantile,percentile) # get quantile for specific channel\n  names(res) &lt;- matched_chnl[[\"desc\"]]\n  return(res)\n}\n\n# get stats\nmedian_cd4 &lt;- gs_pop_get_stats(gs,\n                 c(\"lymphocytes\",\"CD3+ T cells\",\"CD4+CD8a-\",\"CD4-CD8a+\"), \n                 type = my_quantile,\n                 inverse.transform = TRUE,\n                 stats.fun.arg = list(percentile = .5,\n                                      chnl = \"cd4\")) \nknitr::kable(median_cd4,caption = \"Median expression of CD4 extracted using user defined function\")\n\n\nMedian expression of CD4 extracted using user defined function\n\n\nsample\npop\nCD4 BUV805\n\n\n\n\n4000_TNK-CR1\nlymphocytes\n1043.205715\n\n\n4000_TNK-CR1\nCD3+ T cells\n1393.012354\n\n\n4000_TNK-CR1\nCD4+CD8a-\n1866.839339\n\n\n4000_TNK-CR1\nCD4-CD8a+\n3.203119\n\n\n4001_TNK-CR1\nlymphocytes\n873.184795\n\n\n4001_TNK-CR1\nCD3+ T cells\n1366.918737\n\n\n4001_TNK-CR1\nCD4+CD8a-\n1805.953805\n\n\n4001_TNK-CR1\nCD4-CD8a+\n4.153675\n\n\n4002_TNK-CR1\nlymphocytes\n328.090372\n\n\n4002_TNK-CR1\nCD3+ T cells\n959.012183\n\n\n4002_TNK-CR1\nCD4+CD8a-\n1401.996476\n\n\n4002_TNK-CR1\nCD4-CD8a+\n-8.668585\n\n\n4003_TNK-CR1\nlymphocytes\n785.155278\n\n\n4003_TNK-CR1\nCD3+ T cells\n1486.741756\n\n\n4003_TNK-CR1\nCD4+CD8a-\n1758.953449\n\n\n4003_TNK-CR1\nCD4-CD8a+\n-9.211168\n\n\n\n\n\nAs we see, we were able to extract median expression of the marker CD4 on 4 different populations. As expected, expression is highest on CD4+ T Cells and lowest on CD8+ T Cells."
  },
  {
    "objectID": "vignettes/5_Gating_gatingTemplate.html",
    "href": "vignettes/5_Gating_gatingTemplate.html",
    "title": "Gating Cells in cytoverse using gatingTemplates (optional)",
    "section": "",
    "text": "In Part 1 we identified various gates available in cytoverse and how to use them. Here, we show how users can compose a similar gating scheme by using a gatingTemplate.\nA gatingTemplate is a csv file that describes the gating sequence and the gating methods. In the gatingTemplate csv file, we can leverage the various automated gating methods that we have previously seen, without explicitly requiring to script it in R.\nLet’s take a look at an example gatingTemplate\n\n# load gatingTemplate csv\nknitr::kable(read.csv(\"data/gating-template/gating_template_TNK.csv\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nalias\npop\nparent\ndims\ngating_method\ngating_args\ncollapseDataForGating\ngroupBy\npreprocessing_method\npreprocessing_args\n\n\n\n\nsinglet\n+\nroot\nFSC-A,FSC-H\nsingletGate\nwider_gate=FALSE,prediction_level=0.95\nFALSE\nNA\nNA\nNA\n\n\nlive\n-\nsinglet\nLive\ngate_quantile\nprobs = 0.95\nFALSE\nNA\nNA\nNA\n\n\nlymphocytes\n+\nlive\nFSC-A,SSC-A\nflowClust.2d\nK = 1,target = c(1E5,0.5E3)\nFALSE\nNA\nNA\nNA\n\n\nCD3 + Cells\n+\nlymphocytes\nCD3\nmindensity\n\nNA\nNA\nNA\nNA\n\n\nnon-NKT Cells\n-\nCD3 + Cells\nCD1d\nmindensity\n\nTRUE\nstatus\nNA\nNA\n\n\nNKT Cells\n+\nCD3 + Cells\nCD1d\nmindensity\ngate_range=c(130,200),min = 130\nTRUE\nstatus\nNA\nNA\n\n\nTrue_NKT Cells\n+\nNKT Cells\nCD1d,CD3\nflowClust.2d\nK=2,target=c(150,175)\nTRUE\nstatus\nNA\nNA\n\n\nConv T Cells\n–\nnon-NKT Cells\nVd1,Vg9\nmindensity\n\nFALSE\nNA\nNA\nNA\n\n\nMAIT Cells\n++\nConv T Cells\nCD161,TCR Va7_2\ngate_quantile\nprobs = 0.97\nTRUE\nstatus\nNA\nNA\n\n\nnot_MAIT Cells\n+\nConv T Cells\n\nboolGate\n!MAIT Cells\nNA\n\nNA\nNA\n\n\nCD4_ref\n+\nnot_MAIT Cells\nCD4\nmindensity\n\nNA\n\nNA\nNA\n\n\nCD8_ref\n+\nnot_MAIT Cells\nCD8\nmindensity\n\nNA\n\nNA\nNA\n\n\nCD4+ T Cells\n+-\nnot_MAIT Cells\nCD4,CD8\nrefGate\nCD4_ref:CD8_ref\nNA\n\nNA\nNA\n\n\nCD8+ T Cells\n-+\nnot_MAIT Cells\nCD4,CD8\nrefGate\nCD4_ref:CD8_ref\nNA\n\nNA\nNA\n\n\n\n\n\n\n\nThere are 10 columns that are required in a gatingTemplate csv file:\n\nalias# : name (alias) of the gate\npop# : + or -; a combination such as: –, -+, ++, +-; *.\nparent# : parent population\ndims# : channels or markernames\ngating_method# : gating method to be used. example: mindensity\ngating_args: additional arguments that can be passed to gating_methods\ncollapseDataForGating: logical indicating if the data is to be collapsed onto a single flowFrame before estimation\ngroupBy: string indicating the grouping variable (within pData slot of the GatingSet)\npreprocessing_method: preprocessing method to be used\npreprocessing_args: additional arguments that can be passed to preprocessing_method\n\nNote: # indicates that these fields must be completed. Others can be left blank.\n\n\n\nAbove, It should be apparent that the each row of the gatingTemplate csv file is akin to the function call to a specific type of gate.\nLet’s take a look at a simple example of the node singlet:\n\nalias: singlet name of the gate\npop: + indicating that we want events inside the gate\nparent: root indicating the parent population\ndims: FSC-A,FSC-H indicating the channels that the function should use\ngating_method: singletGate indicating the gating method\ngating_args:wider_gate=FALSE,prediction_level=0.95 indicating a tight gate\ncollapseDataForGating: FALSE indicating not to collapse the entire GatingSet into 1 flowFrame for estimation\ngroupBy: NA indicating that no grouping is to be done\npreprocessing_method: NA indicating that no preprocessing is to be done\npreprocessing_args: NA indicating that no preprocessing argument is specified\n\nThe row for the CD4+ T Cells we note:\n\ngating_method: refGate\ngating_args: CD4_ref:CD8_ref\n\nA refGate (reference gate) allows us to build gates by providing references to a previously constructed gates. In this instance, we first constructed 1D gates CD4_ref and CD8_ref, and leveraged them to generate our CD4+ T Cells gate.\nAlso note:\n\npop:+-\ndims: CD4,CD8\n\nHere we indicated that CD4+ T Cells are CD4+ and CD8-.\nA word of caution: We did not specify channels, rather we left openCyto to match the dims argument with markernames of the GatingSet. If there are similarly named markers (CD3 and CD33) and we provide dims: CD3, the process will not complete successfully!"
  },
  {
    "objectID": "vignettes/5_Gating_gatingTemplate.html#using-opencyto-gatingtemplate",
    "href": "vignettes/5_Gating_gatingTemplate.html#using-opencyto-gatingtemplate",
    "title": "Gating Cells in cytoverse using gatingTemplates (optional)",
    "section": "",
    "text": "In Part 1 we identified various gates available in cytoverse and how to use them. Here, we show how users can compose a similar gating scheme by using a gatingTemplate.\nA gatingTemplate is a csv file that describes the gating sequence and the gating methods. In the gatingTemplate csv file, we can leverage the various automated gating methods that we have previously seen, without explicitly requiring to script it in R.\nLet’s take a look at an example gatingTemplate\n\n# load gatingTemplate csv\nknitr::kable(read.csv(\"data/gating-template/gating_template_TNK.csv\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nalias\npop\nparent\ndims\ngating_method\ngating_args\ncollapseDataForGating\ngroupBy\npreprocessing_method\npreprocessing_args\n\n\n\n\nsinglet\n+\nroot\nFSC-A,FSC-H\nsingletGate\nwider_gate=FALSE,prediction_level=0.95\nFALSE\nNA\nNA\nNA\n\n\nlive\n-\nsinglet\nLive\ngate_quantile\nprobs = 0.95\nFALSE\nNA\nNA\nNA\n\n\nlymphocytes\n+\nlive\nFSC-A,SSC-A\nflowClust.2d\nK = 1,target = c(1E5,0.5E3)\nFALSE\nNA\nNA\nNA\n\n\nCD3 + Cells\n+\nlymphocytes\nCD3\nmindensity\n\nNA\nNA\nNA\nNA\n\n\nnon-NKT Cells\n-\nCD3 + Cells\nCD1d\nmindensity\n\nTRUE\nstatus\nNA\nNA\n\n\nNKT Cells\n+\nCD3 + Cells\nCD1d\nmindensity\ngate_range=c(130,200),min = 130\nTRUE\nstatus\nNA\nNA\n\n\nTrue_NKT Cells\n+\nNKT Cells\nCD1d,CD3\nflowClust.2d\nK=2,target=c(150,175)\nTRUE\nstatus\nNA\nNA\n\n\nConv T Cells\n–\nnon-NKT Cells\nVd1,Vg9\nmindensity\n\nFALSE\nNA\nNA\nNA\n\n\nMAIT Cells\n++\nConv T Cells\nCD161,TCR Va7_2\ngate_quantile\nprobs = 0.97\nTRUE\nstatus\nNA\nNA\n\n\nnot_MAIT Cells\n+\nConv T Cells\n\nboolGate\n!MAIT Cells\nNA\n\nNA\nNA\n\n\nCD4_ref\n+\nnot_MAIT Cells\nCD4\nmindensity\n\nNA\n\nNA\nNA\n\n\nCD8_ref\n+\nnot_MAIT Cells\nCD8\nmindensity\n\nNA\n\nNA\nNA\n\n\nCD4+ T Cells\n+-\nnot_MAIT Cells\nCD4,CD8\nrefGate\nCD4_ref:CD8_ref\nNA\n\nNA\nNA\n\n\nCD8+ T Cells\n-+\nnot_MAIT Cells\nCD4,CD8\nrefGate\nCD4_ref:CD8_ref\nNA\n\nNA\nNA\n\n\n\n\n\n\n\nThere are 10 columns that are required in a gatingTemplate csv file:\n\nalias# : name (alias) of the gate\npop# : + or -; a combination such as: –, -+, ++, +-; *.\nparent# : parent population\ndims# : channels or markernames\ngating_method# : gating method to be used. example: mindensity\ngating_args: additional arguments that can be passed to gating_methods\ncollapseDataForGating: logical indicating if the data is to be collapsed onto a single flowFrame before estimation\ngroupBy: string indicating the grouping variable (within pData slot of the GatingSet)\npreprocessing_method: preprocessing method to be used\npreprocessing_args: additional arguments that can be passed to preprocessing_method\n\nNote: # indicates that these fields must be completed. Others can be left blank.\n\n\n\nAbove, It should be apparent that the each row of the gatingTemplate csv file is akin to the function call to a specific type of gate.\nLet’s take a look at a simple example of the node singlet:\n\nalias: singlet name of the gate\npop: + indicating that we want events inside the gate\nparent: root indicating the parent population\ndims: FSC-A,FSC-H indicating the channels that the function should use\ngating_method: singletGate indicating the gating method\ngating_args:wider_gate=FALSE,prediction_level=0.95 indicating a tight gate\ncollapseDataForGating: FALSE indicating not to collapse the entire GatingSet into 1 flowFrame for estimation\ngroupBy: NA indicating that no grouping is to be done\npreprocessing_method: NA indicating that no preprocessing is to be done\npreprocessing_args: NA indicating that no preprocessing argument is specified\n\nThe row for the CD4+ T Cells we note:\n\ngating_method: refGate\ngating_args: CD4_ref:CD8_ref\n\nA refGate (reference gate) allows us to build gates by providing references to a previously constructed gates. In this instance, we first constructed 1D gates CD4_ref and CD8_ref, and leveraged them to generate our CD4+ T Cells gate.\nAlso note:\n\npop:+-\ndims: CD4,CD8\n\nHere we indicated that CD4+ T Cells are CD4+ and CD8-.\nA word of caution: We did not specify channels, rather we left openCyto to match the dims argument with markernames of the GatingSet. If there are similarly named markers (CD3 and CD33) and we provide dims: CD3, the process will not complete successfully!"
  },
  {
    "objectID": "vignettes/5_Gating_gatingTemplate.html#visualizing-the-gatingtemplate-tree",
    "href": "vignettes/5_Gating_gatingTemplate.html#visualizing-the-gatingtemplate-tree",
    "title": "Gating Cells in cytoverse using gatingTemplates (optional)",
    "section": "Visualizing the gatingTemplate tree",
    "text": "Visualizing the gatingTemplate tree\nLet us now parse this csv file into a gatingTemplate object\n\n# required library\nlibrary(openCyto)\n\n# directly read in a csv\ngt &lt;- openCyto::gatingTemplate(\"data/gating-template/gating_template_TNK.csv\")\n\nNow that we have gt we should first visualize the hierarchy to confirm that it matches our expectations! To achieve this we use plot. As well, we will compare it to the GatingSet we created earlier.\n\n# show gt\nplot(gt)\n\n\n\n\nThe tree diagram summarizes the gating path as well as the gating methods used. Also note that the grey colored arrows identify helper gates. These are gates which constructed in to help construct a final gate. Above, the gate for MAIT Cells is to be created by first constructing 2, 1D gates TCR Va7_2+ and CD161+.\n\n# show gs\nplot(gs)\n\n\n\n\nBeside the names, most nodes look the same!"
  },
  {
    "objectID": "vignettes/5_Gating_gatingTemplate.html#adding-a-new-population",
    "href": "vignettes/5_Gating_gatingTemplate.html#adding-a-new-population",
    "title": "Gating Cells in cytoverse using gatingTemplates (optional)",
    "section": "Adding a new population",
    "text": "Adding a new population\nLet’s append a 1 more population to this scheme: - Non Naive defined as CCR7+CD45RA- or CCR7-CD45RA- or CCR7-CD45RA+\nTo do this, we first create a Naive node and then negate it!\n\n# Non Naive\nadditional_rows &lt;- data.frame(\n  alias = c(\"Naive\", \"Non Naive\"),\n  pop = c(\"++\",\"+\"),\n  parent = c(\"CD4+ T Cells\",\"CD4+ T Cells\"),\n  dims = c(\"CCR7,CD45RA\",\"CCR7,CD45RA\"),\n  gating_method = c(\"mindensity\", \"boolGate\"),\n  gating_args = c(\"\",\"!Naive\"),\n  collapseDataForGating = c(\"\",\"\"),\n  groupBy = c(\"\",\"\"),\n  preprocessing_method = c(\"\",\"\"),\n  preprocessing_args = c(\"\",\"\")\n)\n\ngt &lt;- read.csv(\"data/gating-template/gating_template_TNK.csv\") |&gt;\n  rbind(additional_rows)|&gt; data.table::as.data.table()|&gt;\n  gatingTemplate() \n\n# visualize\nplot(gt)"
  },
  {
    "objectID": "vignettes/5_Gating_gatingTemplate.html#running-and-attaching-the-nodes-to-the-gatingset",
    "href": "vignettes/5_Gating_gatingTemplate.html#running-and-attaching-the-nodes-to-the-gatingset",
    "title": "Gating Cells in cytoverse using gatingTemplates (optional)",
    "section": "Running and attaching the nodes to the GatingSet",
    "text": "Running and attaching the nodes to the GatingSet\nSince we have saved our GatingSet let’s first remove all the nodes including and downstream of singlet.\n\n# clean gs\ngs_pop_remove(gs, \"singlet\") # removes singlet and all children nodes\nrecompute(gs)\n\nWe now use gt_gating(gt,gs) to estimate and attach gates to the GatingSet in a single call.\n\n# add gates defined in gatingTemplate\ngt_gating(gt, gs) # simply provide the parsed gatingTemplate and the GatingSet\nrecompute(gs)\n\n# visualize Gating Hierarchy\nplot(gs, bool = TRUE)\n\n\n\n\nWe see that all the helper gates are also visualized. We can’t remove them as it would affect downstream nodes! However we can hide them.\n\n# Too many nodes being shown, let's hide helper gates\ngt_toggle_helpergates(gt,gs)\n\n# surface MAIT Cells\n## labelled as helper since not_MAIT_Cells was created using reference for MAIT Cells\ngs_pop_set_visibility(gs,\n                      c(\"MAIT Cells\"),\n                      TRUE)\n\n$`4000_TNK-CR1`\nNULL\n\n$`4001_TNK-CR1`\nNULL\n\n$`4002_TNK-CR1`\nNULL\n\n$`4003_TNK-CR1`\nNULL\n\n# visualize the full gated data\nautoplot(gs[[2]], bool = TRUE, bins = 128)+\n  ggcyto_par_set(limits = \"data\")"
  },
  {
    "objectID": "vignettes/5_Gating_gatingTemplate.html#conclusion",
    "href": "vignettes/5_Gating_gatingTemplate.html#conclusion",
    "title": "Gating Cells in cytoverse using gatingTemplates (optional)",
    "section": "Conclusion",
    "text": "Conclusion\nIn this section we took a brief look at how to use a gatingTemplate csv file to compose and rapidly gate cells within a GatingSet. The portability of the gatingTemplate csv ensures that all users utilizing this template file will result in the exact same GatingHierarchy and gates.\nThere are additional functionalities in the openCyto library, which we did not go over due to time constraints. We encourage participants to explore the examples outlined here as well as read through the vignette."
  },
  {
    "objectID": "vignettes/1_Import_fcs.html",
    "href": "vignettes/1_Import_fcs.html",
    "title": "Basics of working with FCS files",
    "section": "",
    "text": "Flow cytometry data (regardless of the type of instrument used) is generally saved as a .fcs file. This file is populated with raw data, fluorescence intensity (for optics based technologies) and abundance (for mass cytrometry), as well as various metadata including: user id, instrument id, dynamic range of instrument, etc. It is important to be able to interact with and manipulate the .fcs file as it gives the users/analysts fine grain control."
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#introduction",
    "href": "vignettes/1_Import_fcs.html#introduction",
    "title": "Basics of working with FCS files",
    "section": "",
    "text": "Flow cytometry data (regardless of the type of instrument used) is generally saved as a .fcs file. This file is populated with raw data, fluorescence intensity (for optics based technologies) and abundance (for mass cytrometry), as well as various metadata including: user id, instrument id, dynamic range of instrument, etc. It is important to be able to interact with and manipulate the .fcs file as it gives the users/analysts fine grain control."
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#installingloading-required-libraries",
    "href": "vignettes/1_Import_fcs.html#installingloading-required-libraries",
    "title": "Basics of working with FCS files",
    "section": "Installing/loading required libraries",
    "text": "Installing/loading required libraries\nYou can install all the required packages as follows:\n\nif (!require(\"BiocManager\", quietly = TRUE))\n  install.packages(\"BiocManager\")\n\nBiocManager::install(c(\"cytolib\", \"flowCore\", \"flowWorkspace\", \"ggcyto\", \n                       \"openCyto\", \"flowStats\", \"CytoML\", \"flowClust\",\n                       \"flowClean\", \"flowAI\", \"PeacoQC\"))\n\nFor the moment, we only need to load flowCore and flowWorkspace.\n\nlibrary(flowCore)\nlibrary(flowWorkspace)"
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#flowrepository-workshop-data",
    "href": "vignettes/1_Import_fcs.html#flowrepository-workshop-data",
    "title": "Basics of working with FCS files",
    "section": "FlowRepository workshop data",
    "text": "FlowRepository workshop data\nIn this workshop we will demonstrate the use of different R packages to analyse publicly available datasets hosted on FlowRepository. The first dataset FR-FCM-Z5PC contains FCS files from a study assessing the post recovery immune phenotypes from patients infected with COVID-19. We are using a subset of the FCS files. The second dataset FR-FCM-ZZ36 contains FCS files for OMIP-018, a study designed to phenotype T cells for expression of various chemokine receptors.\nThe data required for this workshop, including subsets extracted from the FlowRepository datasets are made available inside vignettes/data folder."
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#cytoverse-data-structures-for-.fcs-files",
    "href": "vignettes/1_Import_fcs.html#cytoverse-data-structures-for-.fcs-files",
    "title": "Basics of working with FCS files",
    "section": "cytoverse data structures for .fcs files",
    "text": "cytoverse data structures for .fcs files\nThere are four main data structures that represent flow cytometry data in cytoverse: cytoframe, cytoset, GatingHierarchy and GatingSet.\n\ncytoframe: a single .fcs file,\ncytoset: a list like object that can store multiple .fcs files,\nGatingHierarchy: a list like object that allows building and attaching gates and filter to a cytoframe\nGatingSet: a list like object that allows building and attaching gates and filter to a cytoset\n\nSome of these have overlapping functionality, and we’ll eventually explain when you would prefer one data structure to another as we continue through this workshop.\nThere are additional legacy data structures called flowFrame and flowSet in cytoverse that are analogous to cytoframe and cytoset in function. We will briefly discuss these data structures in this workshop."
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#reading-an-fcs-file",
    "href": "vignettes/1_Import_fcs.html#reading-an-fcs-file",
    "title": "Basics of working with FCS files",
    "section": "Reading an FCS file",
    "text": "Reading an FCS file\nThere are two preferred approaches to read in .fcs file(s) into R:\n\nRead in individual .fcs files as cytoframe (associated with flowWorkspace package) or flowFrame (associated with flowCore package)\nRead in a set of .fcs files as cytoset (associated with flowWorkspace package) or flowSet (associated with flowCore package)\n\n(Additionally, you can read a workspace generated with another tool, such as FlowJo, using the CytoML package.)\n\nWorking with cytoframe or flowFrame objects\nA few useful definitions that help us get oriented with the underlying data in the cytoframe/flowFrame object.\n\nChannels: Instrument derived labels of various parameters that were measured. Channels are the column names of the cytoframe/flowFrame. Any data generated from the same instrument will have the same (similar) Channel names.\nMarkers: User provided labels for various parameters that were measured. For example: Channel name: B710-A, Marker name: CD3. Marker names are set by the users and may not be unique across experiments/users. Not all channels are markers – some are physical parameters such as the forward scatter or side scatter. These channels will have their marker names set to NA.\nExpression: Measured values. A matrix where every row is an event (frequently a cell) and every column is a channel.\n\nWorking with a cytoframe/flowFrame object is very similar to working with a data.frame in R, where a “row” is a cell and a “column” is a channel.\n\nReading an FCS file as a cytoframe object\nThe function load_cytoframe_from_fcs is used to read in individual file as a cytoframe object.\n\ncf &lt;- load_cytoframe_from_fcs(\"data/fcs-data/4000_BDC-CR1.fcs\")\n# a cytoframe object\ncf\n\ncytoframe object '4000_BDC-CR1.fcs'\nwith 912254 cells and 33 observables:\n                  name         desc     range  minRange  maxRange\n$P1              FSC-A           NA    262143     0.000    262143\n$P2              FSC-H           NA    262143     0.000    262143\n$P3              SSC-A           NA    262143     0.000    262143\n$P4             B515-A   CADM1 FITC    262143  -110.386    262143\n$P5             B610-A  CD141 BB630    262143  -111.000    262143\n...                ...          ...       ...       ...       ...\n$P29            V710-A   CD86 BV711    262143      -111    262143\n$P30            V750-A CX3CR1 BV750    262143      -111    262143\n$P31            V785-A HLA-DR BV786    262143      -111    262143\n$P32 remove_from_FS_FM           QC    262143         0    262143\n$P33              Time           NA        92         0        92\n327 keywords are stored in the 'description' slot\nrow names(0):\n\n\n\n\nReading an FCS file as a flowFrame object\nTo read a FCS file as a flowFrame object: (standard for Flow Cytometry)\n\nff &lt;- read.FCS(\"data/fcs-data/4000_BDC-CR1.fcs\")\n# a flowFrame object\nff\n\nflowFrame object '210217_COVID-CR_BDC-CR1_Run 1_Samples_Plate 1_A1_A01_001.fcs'\nwith 912254 cells and 33 observables:\n                  name         desc     range  minRange  maxRange\n$P1              FSC-A           NA    262144     0.000    262144\n$P2              FSC-H           NA    262144     0.000    262144\n$P3              SSC-A           NA    262144     0.000    262144\n$P4             B515-A   CADM1 FITC    262144  -110.386    262144\n$P5             B610-A  CD141 BB630    262144  -111.000    262144\n...                ...          ...       ...       ...       ...\n$P29            V710-A   CD86 BV711    262144      -111    262144\n$P30            V750-A CX3CR1 BV750    262144      -111    262144\n$P31            V785-A HLA-DR BV786    262144      -111    262144\n$P32 remove_from_FS_FM           QC    262144         0    262144\n$P33              Time           NA        93         0     20000\n326 keywords are stored in the 'description' slot\n\n\n\n\ncytoframe versus flowFrame objects\nBoth cytoframe and flowFrame object has 3 slots where various data is stored.\n\nexprs(cf): stores the expression matrix (i.e. the collected data),\nparameters(cf): stores information pertaining to channels: channel name, marker description,and data ranges as an AnnotatedDataFrame,\nkeyword(cf): stores additional information extracted from the .fcs file header. The file header follow ISAC guidelines. Visit here for more information.\n\n\n\n\nFigure 1: Overview of cytoframe/flowFrame object\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn R, the @ and $ operators serve the purpose of accessing elements within an object. However, it is to employ these operators for accessing elements directly. A recommended practice is to use functions and methods explicitly designed for this purpose, as will be discussed in the next section.\n\nTo extract any or slot shown in Figure 1 the @ operator is used. On the other hand, to extract any slot the $ operator is used.\nIn general, the @ operator is used to extract/replace contents of a slot or property of an object. The $ operator is used to extract/replace parts on vectors, matrices, arrays or lists.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nInteracting with a cytoframe is very similar to interacting with a flowframe, with one important difference. While operations such as subsetting or copying a flowFrame using the standard R assignment operator (&lt;-) will perform a deep copy of the data in its slots, the same operations on a cytoframe will produce a view to the same underlying data as the original object. This means that changes made to the cytoframe resulting from subsetting or copying will affect the original cytoframe.\n\n\nFrom this point onwards, we focus on examples and usages involving the cytoframe object, with the majority of the content dedicated to exploring and understanding this specific data structure.\n\n\n\nExamples\n\nAccessing parameter summary and metadata\nSummary of measured parameters.\n\n# parameters\nparameters(cf) |&gt; pData() # show as a dataframe\n\n                  name              desc  range   minRange maxRange\n$P1              FSC-A              &lt;NA&gt; 262143    0.00000   262143\n$P2              FSC-H              &lt;NA&gt; 262143    0.00000   262143\n$P3              SSC-A              &lt;NA&gt; 262143    0.00000   262143\n$P4             B515-A        CADM1 FITC 262143 -110.38593   262143\n$P5             B610-A       CD141 BB630 262143 -111.00000   262143\n$P6             B660-A       CD123 BB660 262143 -111.00000   262143\n$P7             B710-A      FcER1a BB700 262143 -111.00000   262143\n$P8             B780-A         IgD BB790 262143 -111.00000   262143\n$P9             G575-A         IFNAR2 PE 262143 -111.00000   262143\n$P10            G610-A CD88 PE-Dazzle594 262143 -111.00000   262143\n$P11            G660-A        CD3 PE-Cy5 262143 -111.00000   262143\n$P12            G710-A       CD5 PE-Cy55 262143 -111.00000   262143\n$P13            G780-A       CCR1 PE-Cy7 262143 -111.00000   262143\n$P14            R670-A         CD11c APC 262143 -111.00000   262143\n$P15            R730-A     CD27 APC-R700 262143 -111.00000   262143\n$P16            R780-A  XCR1 APC-Fire750 262143 -111.00000   262143\n$P17            U390-A       CCR3 BUV395 262143 -111.00000   262143\n$P18            U450-A Live Dead UV Blue 262143 -102.92210   262143\n$P19            U500-A       CD40 BUV496 262143 -111.00000   262143\n$P20            U570-A       CD56 BUV563 262143 -100.80198   262143\n$P21            U660-A       CD21 BUV661 262143 -111.00000   262143\n$P22            U740-A      CD163 BUV737 262143 -111.00000   262143\n$P23            U785-A       CD20 BUV805 262143 -111.00000   262143\n$P24            V450-A        CCR2 BV421 262143 -111.00000   262143\n$P25            V510-A        CD14 BV510 262143 -106.44221   262143\n$P26            V570-A        CD16 BV570 262143 -111.00000   262143\n$P27            V605-A        CD38 BV605 262143  -93.17506   262143\n$P28            V655-A        CCR5 BV650 262143 -111.00000   262143\n$P29            V710-A        CD86 BV711 262143 -111.00000   262143\n$P30            V750-A      CX3CR1 BV750 262143 -111.00000   262143\n$P31            V785-A      HLA-DR BV786 262143 -111.00000   262143\n$P32 remove_from_FS_FM                QC 262143    0.00000   262143\n$P33              Time              &lt;NA&gt;     92    0.00000       92\n\n\nVarious metadata present in the .fcs files.\n\n# keywords\nkeyword(cf) |&gt; head(10) # only show the first 10\n\n$FCSversion\n[1] \"3\"\n\n$`$FIL`\n[1] \"4000_BDC-CR1.fcs\"\n\n$`$TOT`\n[1] \"912254\"\n\n$`$PAR`\n[1] \"33\"\n\n$`$BYTEORD`\n[1] \"4,3,2,1\"\n\n$`$DATATYPE`\n[1] \"F\"\n\n$FJ_FCS_VERSION\n[1] \"3\"\n\n$`$BEGINANALYSIS`\n[1] \"0\"\n\n$`$BEGINSTEXT`\n[1] \"0\"\n\n$`$BTIM`\n[1] \"10:29:03\"\n\n\n\n\nChannels, Expression, and Subsets\n\n# channels\ncolnames(cf)\n\n [1] \"FSC-A\"             \"FSC-H\"             \"SSC-A\"            \n [4] \"B515-A\"            \"B610-A\"            \"B660-A\"           \n [7] \"B710-A\"            \"B780-A\"            \"G575-A\"           \n[10] \"G610-A\"            \"G660-A\"            \"G710-A\"           \n[13] \"G780-A\"            \"R670-A\"            \"R730-A\"           \n[16] \"R780-A\"            \"U390-A\"            \"U450-A\"           \n[19] \"U500-A\"            \"U570-A\"            \"U660-A\"           \n[22] \"U740-A\"            \"U785-A\"            \"V450-A\"           \n[25] \"V510-A\"            \"V570-A\"            \"V605-A\"           \n[28] \"V655-A\"            \"V710-A\"            \"V750-A\"           \n[31] \"V785-A\"            \"remove_from_FS_FM\" \"Time\"             \n\n# markernames\nmarkernames(cf)\n\n             B515-A              B610-A              B660-A              B710-A \n       \"CADM1 FITC\"       \"CD141 BB630\"       \"CD123 BB660\"      \"FcER1a BB700\" \n             B780-A              G575-A              G610-A              G660-A \n        \"IgD BB790\"         \"IFNAR2 PE\" \"CD88 PE-Dazzle594\"        \"CD3 PE-Cy5\" \n             G710-A              G780-A              R670-A              R730-A \n      \"CD5 PE-Cy55\"       \"CCR1 PE-Cy7\"         \"CD11c APC\"     \"CD27 APC-R700\" \n             R780-A              U390-A              U450-A              U500-A \n \"XCR1 APC-Fire750\"       \"CCR3 BUV395\" \"Live Dead UV Blue\"       \"CD40 BUV496\" \n             U570-A              U660-A              U740-A              U785-A \n      \"CD56 BUV563\"       \"CD21 BUV661\"      \"CD163 BUV737\"       \"CD20 BUV805\" \n             V450-A              V510-A              V570-A              V605-A \n       \"CCR2 BV421\"        \"CD14 BV510\"        \"CD16 BV570\"        \"CD38 BV605\" \n             V655-A              V710-A              V750-A              V785-A \n       \"CCR5 BV650\"        \"CD86 BV711\"      \"CX3CR1 BV750\"      \"HLA-DR BV786\" \n  remove_from_FS_FM \n               \"QC\" \n\n# instrument channel ranges\nrange(cf, type = \"instrument\")\n\n     FSC-A  FSC-H  SSC-A      B515-A B610-A B660-A B710-A B780-A G575-A G610-A\nmin      0      0      0   -110.3859   -111   -111   -111   -111   -111   -111\nmax 262143 262143 262143 262143.0000 262143 262143 262143 262143 262143 262143\n    G660-A G710-A G780-A R670-A R730-A R780-A U390-A      U450-A U500-A\nmin   -111   -111   -111   -111   -111   -111   -111   -102.9221   -111\nmax 262143 262143 262143 262143 262143 262143 262143 262143.0000 262143\n        U570-A U660-A U740-A U785-A V450-A      V510-A V570-A       V605-A\nmin   -100.802   -111   -111   -111   -111   -106.4422   -111    -93.17506\nmax 262143.000 262143 262143 262143 262143 262143.0000 262143 262143.00000\n    V655-A V710-A V750-A V785-A remove_from_FS_FM Time\nmin   -111   -111   -111   -111                 0    0\nmax 262143 262143 262143 262143            262143   92\n\n# expression\nexprs(cf)[1:5, 1:5]\n\n         FSC-A    FSC-H    SSC-A   B515-A     B610-A\n[1,]  37806.11 33978.14 517.8660 136.6147   27.66158\n[2,] 105788.00 91726.41 550.5819 230.8201  331.49930\n[3,] 119658.92 96086.12 980.8203 275.5523 4240.47754\n[4,]  65660.55 57019.41 795.2517 407.6333  244.19577\n[5,] 119732.59 95060.98 555.4248 382.0113  648.48053\n\n# number of events\nnrow(cf)\n\n[1] 912254\n\n# number of channels \nncol(cf)\n\n[1] 33\n\n# dimesnions (nrows, nclos)\ndim(cf)\n\n    events parameters \n    912254         33 \n\n\nNotice that there is a correspondence between channels, markers, and the expression matrix. i.e. the names of the named vector markernames(cf) are a subset of the columns of the expression matrix exprs(cf) as well as the columns of the cytoframe.\n\n\nPreliminary statistics\n\n# summary of expression\nsummary(cf)\n\n            FSC-A     FSC-H       SSC-A     B515-A      B610-A      B660-A\nMin.     34304.25  19999.50    2.240518  -110.3859   -132.2740   -210.3732\n1st Qu.  87272.29  70237.66  486.419678   208.1194    341.8090   7191.6100\nMedian  102740.58  83518.11  644.271606   302.8436    478.9301  13205.1885\nMean    101498.35  81101.55  786.391709   397.1372   1304.2548  14723.4119\n3rd Qu. 115452.03  93740.46  870.288940   477.7771    770.2125  20234.5640\nMax.    252405.12 209127.45 8274.216797 22591.7363 117936.5469 261941.1562\n           B710-A      B780-A      G575-A      G610-A      G660-A      G710-A\nMin.     -163.470   -197.9384   -142.9593   -129.1895   -252.0787   -217.6541\n1st Qu.  1898.958   1073.3176    978.4369    559.1452   5301.9827   6801.0914\nMedian   3525.223   1705.6006   1443.8180    866.7194   8866.5322  12812.9512\nMean     3833.847   2519.1960   2345.0305   2245.0479   9856.0090  13506.8896\n3rd Qu.  5376.914   2675.5859   2183.2964   1633.7214  13186.8789  18895.0566\nMax.    48943.254 241104.0156 255001.0469 112351.6562 165428.4688 154505.8750\n            G780-A     R670-A      R730-A     R780-A      U390-A     U450-A\nMin.     -184.6585  -127.0588   -169.4118  -138.3760  -124.05902 -102.92210\n1st Qu.  1386.5303  1657.2997   3418.5791   580.2402    44.37574   18.90896\nMedian   2110.0955  2431.9084   9204.0547  1256.1080   109.50300   63.70048\nMean     2470.5234  2823.0625   9533.2850  1299.7730   538.77084  190.49138\n3rd Qu.  3052.3540  3452.9258  14523.9941  1784.7538   300.42612  170.46536\nMax.    82854.4844 47455.3984 242545.5781 42423.1250 24223.10742 5708.70703\n            U500-A       U570-A     U660-A      U740-A     U785-A      V450-A\nMin.     -226.8526   -100.80198  -129.3914   -178.4754  -176.2910   -138.1614\n1st Qu.   155.8968     90.95654   333.4327    359.4340   125.9876    165.9489\nMedian    340.9289    158.62689   540.0557    554.0002   232.8040    335.9948\nMean     1200.8504    669.29520   890.7766    856.3386  1653.9154   1411.0790\n3rd Qu.   877.6004    574.35419   986.8828    845.4131   427.1417    958.3866\nMax.    78292.7344 151937.20312 42314.3125 152360.4531 85455.1562 135029.0625\n             V510-A     V570-A      V605-A     V655-A      V710-A      V750-A\nMin.      -106.4422  -113.6095   -93.17506  -138.9747   -148.3278   -232.1497\n1st Qu.    185.6013   287.5951    97.03428   566.6487    818.4460    595.6494\nMedian     273.5766   401.7236   236.00162   920.9233   1192.2645    935.9188\nMean       710.7748  1220.4410   853.88758  1317.9599   1436.2447   1335.0108\n3rd Qu.    474.6249   743.7738   774.47632  1541.7345   1691.9939   1475.6022\nMax.    120586.6406 93862.0859 85239.43750 65249.9648 141504.4844 194771.0625\n             V785-A remove_from_FS_FM        Time\nMin.      -216.4427          1.010923    0.004192\n1st Qu.    441.6244       2250.874268  773.810455\nMedian     699.6008       4494.002197 1519.027100\nMean      2389.9065       4497.678615 2191.098990\n3rd Qu.   1242.9441       6744.918945 3590.846069\nMax.    230174.0000       8999.978516 6001.229492\n\n# median value across each row\nrow_stat &lt;- each_row(cf, median)\nhead(row_stat)\n\n[1]   77.88036  591.80017 2567.52710  325.73132 1063.35461  647.29474\n\n# mean value across each row\ncol_stat &lt;- each_col(cf, mean)\nhead(col_stat)\n\n      FSC-A       FSC-H       SSC-A      B515-A      B610-A      B660-A \n101498.3483  81101.5458    786.3917    397.1372   1304.2548  14723.4119 \n\n\nStatistic functions listed under location and scale estimator in matrxStats page can be used as the second argument in each_row(argument1, argument2) and each_col(argument1, argument2) functions.\n\n\nAditional examples\n\n# interested marker: CD4\n# easy to find which channel is mapped to CD4\nCD4_chan &lt;- flowCore::getChannelMarker(\n  frm = cf,\n  name = \"CD4\"\n)$name\n\nWarning in flowCore::getChannelMarker(frm = cf, name = \"CD4\"): CD4 is partially\nmatched with U500-ACD40 BUV496\n\n# inspect CD4_chan\nCD4_chan\n\n[1] \"U500-A\"\n\n# extract expression of cd4\ne_cd4 &lt;- exprs(cf[, CD4_chan])\nhead(e_cd4)\n\n        U500-A\n[1,] 1422.2137\n[2,]  199.7638\n[3,]  344.7379\n[4,] 2167.5317\n[5,]  285.1899\n[6,]  152.0994\n\n# subset cytorame by column\ns_cf &lt;- cf[, CD4_chan]\ns_cf\n\ncytoframe object '4000_BDC-CR1.fcs'\nwith 912254 cells and 1 observables:\n       name        desc     range  minRange  maxRange\n$P19 U500-A CD40 BUV496    262143      -111    262143\n327 keywords are stored in the 'description' slot\nrow names(0):\ncytoframe has been subsetted and can be realized through 'realize_view()'.\n\n# subset cytoframe by row\ns2_cf &lt;- cf[1:100, ]\ns2_cf\n\ncytoframe object '4000_BDC-CR1.fcs'\nwith 100 cells and 33 observables:\n                  name         desc     range  minRange  maxRange\n$P1              FSC-A           NA    262143     0.000    262143\n$P2              FSC-H           NA    262143     0.000    262143\n$P3              SSC-A           NA    262143     0.000    262143\n$P4             B515-A   CADM1 FITC    262143  -110.386    262143\n$P5             B610-A  CD141 BB630    262143  -111.000    262143\n...                ...          ...       ...       ...       ...\n$P29            V710-A   CD86 BV711    262143      -111    262143\n$P30            V750-A CX3CR1 BV750    262143      -111    262143\n$P31            V785-A HLA-DR BV786    262143      -111    262143\n$P32 remove_from_FS_FM           QC    262143         0    262143\n$P33              Time           NA        92         0        92\n327 keywords are stored in the 'description' slot\nrow names(0):\ncytoframe has been subsetted and can be realized through 'realize_view()'.\n\n\nNotice that the subset ([]) operation can be applied directly to the cytoframe object so that information regarding the file is preserved. Also, as indicated above, these operations provide an aliased view of the data without creating a copy.\nBelow, we show examples of how to manipulate the cytoframe object and create a copy using realize_view():\n\n# create a new markername\nnew_name &lt;- c(\"U785-A\" = \"test\")\n\n# create a new cytoframe subset\ncf_sub &lt;- cf[1:150, ] |&gt; realize_view() # realize_view creates a new cytoframe, distinct from the original\n\n# old markernames\nmarkernames(cf_sub)\n\n             B515-A              B610-A              B660-A              B710-A \n       \"CADM1 FITC\"       \"CD141 BB630\"       \"CD123 BB660\"      \"FcER1a BB700\" \n             B780-A              G575-A              G610-A              G660-A \n        \"IgD BB790\"         \"IFNAR2 PE\" \"CD88 PE-Dazzle594\"        \"CD3 PE-Cy5\" \n             G710-A              G780-A              R670-A              R730-A \n      \"CD5 PE-Cy55\"       \"CCR1 PE-Cy7\"         \"CD11c APC\"     \"CD27 APC-R700\" \n             R780-A              U390-A              U450-A              U500-A \n \"XCR1 APC-Fire750\"       \"CCR3 BUV395\" \"Live Dead UV Blue\"       \"CD40 BUV496\" \n             U570-A              U660-A              U740-A              U785-A \n      \"CD56 BUV563\"       \"CD21 BUV661\"      \"CD163 BUV737\"       \"CD20 BUV805\" \n             V450-A              V510-A              V570-A              V605-A \n       \"CCR2 BV421\"        \"CD14 BV510\"        \"CD16 BV570\"        \"CD38 BV605\" \n             V655-A              V710-A              V750-A              V785-A \n       \"CCR5 BV650\"        \"CD86 BV711\"      \"CX3CR1 BV750\"      \"HLA-DR BV786\" \n  remove_from_FS_FM \n               \"QC\" \n\n# set new markername\nmarkernames(cf_sub) &lt;- new_name\nmarkernames(cf_sub)\n\n             B515-A              B610-A              B660-A              B710-A \n       \"CADM1 FITC\"       \"CD141 BB630\"       \"CD123 BB660\"      \"FcER1a BB700\" \n             B780-A              G575-A              G610-A              G660-A \n        \"IgD BB790\"         \"IFNAR2 PE\" \"CD88 PE-Dazzle594\"        \"CD3 PE-Cy5\" \n             G710-A              G780-A              R670-A              R730-A \n      \"CD5 PE-Cy55\"       \"CCR1 PE-Cy7\"         \"CD11c APC\"     \"CD27 APC-R700\" \n             R780-A              U390-A              U450-A              U500-A \n \"XCR1 APC-Fire750\"       \"CCR3 BUV395\" \"Live Dead UV Blue\"       \"CD40 BUV496\" \n             U570-A              U660-A              U740-A              U785-A \n      \"CD56 BUV563\"       \"CD21 BUV661\"      \"CD163 BUV737\"              \"test\" \n             V450-A              V510-A              V570-A              V605-A \n       \"CCR2 BV421\"        \"CD14 BV510\"        \"CD16 BV570\"        \"CD38 BV605\" \n             V655-A              V710-A              V750-A              V785-A \n       \"CCR5 BV650\"        \"CD86 BV711\"      \"CX3CR1 BV750\"      \"HLA-DR BV786\" \n  remove_from_FS_FM \n               \"QC\" \n\n# manipulating expression values\n# notice the data range \nrange(cf_sub[, \"U785-A\"])\n\n    U785-A\nmin   -111\nmax 262143\n\n# visualise original channel ditribution\nplot(\n  density(\n    exprs(cf_sub[, \"U785-A\"])\n  ),\n  main = \"U785-A\"\n)\n\n\n\n# asinh transform\nexprs(cf_sub)[, \"U785-A\"] &lt;- asinh(exprs(cf_sub)[, \"U785-A\"])\n\n# notice the data range after transformation\nrange(\n  cf_sub[, \"U785-A\"],\n  type = \"instrument\"\n)\n\n    U785-A\nmin   -111\nmax 262143\n\n# visualise channel distribution\nplot(\n  density(\n    exprs(cf_sub[, \"U785-A\"])\n  ),\n  main = \"U785-A\"\n)\n\n\n\n\nNotice that the data range summary was not updated when we used &lt;- to change the underlying expression matrix. A good practice is to use transform function to transform the underlying expression matrix. Importantly, transform also updates the data range summary. Moreover, transform can also be used to add new columns to the cytoframe.\nNote: We will go over transformations in a later section.\n\n\n\nBasic plots using flowViz package\nflowViz package provide functions and methods to visualize flow cytometry data. This package heavily depends on the flowCore package.\n\nlibrary(flowViz)\n\n\nExamples\nIf the object has only a single parameter this produces a histogram. To select specific parameters from a flowFrame for plotting, either subset the object or specify the parameters as a character vector as shown below.\n\nplot(cf, c(\"FSC-A\"))\n\n\n\n\nFor exactly two parameters this plots a bivariate density map.\n\nplot(cf, c(\"FSC-A\", \"SSC-A\"))\n\n\n\n\nFor more than two parameters this produce a simple scatter plots matrix (splom). The smooth parameters lets you toggle between density-type smoothScatter plots and regular scatterplots. For far more sophisticated plotting of flow cytometry data, ggcyto package is used generally (will be discussed later).\nFor multiple parameters,\n\nall_param = dput(colnames(cf)[6:8])\n\nc(\"B660-A\", \"B710-A\", \"B780-A\")\n\nplot(cf, all_param)"
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#reading-a-set-of-fcs-files",
    "href": "vignettes/1_Import_fcs.html#reading-a-set-of-fcs-files",
    "title": "Basics of working with FCS files",
    "section": "Reading a set of FCS files",
    "text": "Reading a set of FCS files\nIn a experimental sense, a single .fcs file is not very interesting, since this represents only a single sample. To draw any conclusions, we’ll want replicates. When there are a set of .fcs files they can be loaded into R either as a cytoset or flowSet.\ncytoset/flowSet: A collection of .fcs files, preferably, but not necessarily from the same panel/experiment.\n\nReading a set of FCS files as a cytoset\n\ncs &lt;- load_cytoset_from_fcs(path = \"data/fcs-data/\")\ncs\n\nA cytoset with 6 samples.\n\n  column names:\n    FSC-A, FSC-H, SSC-A, B515-A, B610-A, B660-A, B710-A, B780-A, G575-A, G610-A, G660-A, G710-A, G780-A, R670-A, R730-A, R780-A, U390-A, U450-A, U500-A, U570-A, U660-A, U740-A, U785-A, V450-A, V510-A, V570-A, V605-A, V655-A, V710-A, V750-A, V785-A, remove_from_FS_FM, Time\n\n\n\n\nReading a set of FCS files as a flowSet\n\nframes &lt;- lapply(dir(\"data/fcs-data/\", full.names=TRUE), read.FCS)\nfs &lt;- as(frames, \"flowSet\") \nfs\n\nA flowSet with 6 experiments.\n\ncolumn names(33): FSC-A FSC-H ... remove_from_FS_FM Time\n\n\nA cytoset/flowSet can also be indexed with square brackets cs[i,j], however now the row index i selects samples (individual FCS files) rather than cells. A cytoset/flowSet also behaves like a list – a double bracket cs[[i]] selects a single sample as a cytoframe/flowFrame.\nGenerally, each FCS file replicate has unique metadata properties that can (and should) be supplied to the cytoset/flowSet. These can be added after loading the cytoset/flowSet by using pData(x) &lt;- data.frame. The rownames of the data.frame must match the sampleNames of the cytoset/flowSet.\n\n\n\n\n\n\nNote\n\n\n\nThe primary difference between the cytoset and flowSet classes is in the underlying representation of the data. Because cytoset is a reference class, copying or subsetting a cytoset object will return a cytoset pointing to the same underlying data. A deep copy of the data can be obtained via the realize_view method as before.\nThere is one notable exception to the typical behavior of most methods returning a cytoframe. The standard extraction operator ([[]]) will by default perform a deep copy of the subset being extracted and return a flowFrame.\n\n\nHere onwards, we focus on examples involving the cytoset object, with the majority of the content dedicated to exploring and understanding this specific data structure.\n\n# prior to providing metadata\npData(cs)\n\n                             name\n4000_BDC-CR1.fcs 4000_BDC-CR1.fcs\n4000_TNK-CR1.fcs 4000_TNK-CR1.fcs\n4001_BDC-CR1.fcs 4001_BDC-CR1.fcs\n4001_TNK-CR1.fcs 4001_TNK-CR1.fcs\n4002_TNK-CR1.fcs 4002_TNK-CR1.fcs\n4003_TNK-CR1.fcs 4003_TNK-CR1.fcs\n\n# create metadata\nmetadata &lt;- data.frame(\n  Treatment = rep(c(\"Untreated\",\"Treated\"),\n    length.out = length(cs)\n  ),\n  panel = ifelse(\n    grepl(\n      pattern = \"TNK\",\n      x = sampleNames(cs)\n    ),\n    \"T Cell Panel\",\n    \"Myeloid Panel\"\n  )\n)\n\nLet’s see what happens when rownames do not match!\n\n# try to add metadata  -- this leads to an error\npData(cs) &lt;- metadata\n\nError: Invalid input type, expected 'character' actual 'integer'\n\n\nNow, we ensure that rownames of data.frame matches sampleNames of the cytoset.\n\n# now it works\nrow.names(metadata) &lt;- sampleNames(cs)\npData(cs) &lt;- metadata\npData(cs)\n\n                         panel Treatment\n4000_BDC-CR1.fcs Myeloid Panel Untreated\n4000_TNK-CR1.fcs  T Cell Panel   Treated\n4001_BDC-CR1.fcs Myeloid Panel Untreated\n4001_TNK-CR1.fcs  T Cell Panel   Treated\n4002_TNK-CR1.fcs  T Cell Panel Untreated\n4003_TNK-CR1.fcs  T Cell Panel   Treated\n\n\nThe benefit of having metadata is that we can use many of the sub-setting operations in a metadata specific manner.\nThis is much more convenient than going back and forth between the full set of files.\n\n# subset by files that have myeloid staining panel without creating a copy of the data\ncs_myeloid &lt;- cs[pData(cs)[[\"panel\"]] == \"Myeloid Panel\",]\n\ncs_myeloid\n\nA cytoset with 2 samples.\n\n  column names:\n    FSC-A, FSC-H, SSC-A, B515-A, B610-A, B660-A, B710-A, B780-A, G575-A, G610-A, G660-A, G710-A, G780-A, R670-A, R730-A, R780-A, U390-A, U450-A, U500-A, U570-A, U660-A, U740-A, U785-A, V450-A, V510-A, V570-A, V605-A, V655-A, V710-A, V750-A, V785-A, remove_from_FS_FM, Time\n\npData(cs_myeloid)\n\n                         panel Treatment\n4000_BDC-CR1.fcs Myeloid Panel Untreated\n4001_BDC-CR1.fcs Myeloid Panel Untreated\n\n\n\n\nCytoset views and aliasing\nMany of the sub-setting operation for cytoframe are also applicable for cytoset. Similar to cytoframe sub-setting operations only create a new “view” of the data. For a complete copy of the data, realize_view should be used.\nBelow is an example of cytoset sub-setting which also highlights how the operations performed on cytoset affects the underlying data.\n\n# demonstrate how cs point to the same underlying data\nrange(cs[[1, \"B515-A\"]])\n\n         B515-A\nmin   -110.3859\nmax 262143.0000\n\n# subset and show prior to transformation\ncs_small &lt;- cs[1]\nrange(cs_small[[1, \"B515-A\"]])\n\n         B515-A\nmin   -110.3859\nmax 262143.0000\n\n# create a transformList\ntrans &lt;- transformList(\"B515-A\",asinh)\n\n# transform\ncs_small &lt;- transform(cs_small,trans)\n\n# after transformation\nrange(cs_small[[1, \"B515-A\"]])\n\n       B515-A\nmin -5.397151\nmax 13.169792\n\n# whole cs \nrange(cs[[1, \"B515-A\"]])\n\n       B515-A\nmin -5.397151\nmax 13.169792\n\n\nAs you see, the transformation was applied to a subset cs_small however the original cs was also altered highlighting that both objects were pointing to the same data. To confirm this, you can use cs_get_uri or cf_get_uri:\n\ncs_get_uri(cs_small)\n\n[1] \"/private/var/folders/8g/qvx6xyzs72q3wv286d96s_y91yzgmv/T/RtmpL6UG2b/44ebe911-fe82-45c6-bcb7-0bb250beed5a\"\n\ncs_get_uri(cs)\n\n[1] \"/private/var/folders/8g/qvx6xyzs72q3wv286d96s_y91yzgmv/T/RtmpL6UG2b/44ebe911-fe82-45c6-bcb7-0bb250beed5a\"\n\n\nTo perform a deep copy we can use realize_view()\n\n# look at underlying expression\nrange(cs[[2, \"B515-A\"]])\n\n          B515-A\nmin    -15.63437\nmax 262143.00000\n\n# subset and show prior to transformation\ncs_small2 &lt;- realize_view(cs[2])\nrange(cs_small2[[1, \"B515-A\"]])\n\n          B515-A\nmin    -15.63437\nmax 262143.00000\n\n# create a transformList\ntrans &lt;- transformList(\"B515-A\",asinh)\n\n# transform\ncs_small2 &lt;- transform(cs_small2,trans)\n\n# after transformation\nrange(cs_small2[[1, \"B515-A\"]])\n\n      B515-A\nmin -3.44364\nmax 13.16979\n\n# whole cs \nrange(cs[[2, \"B515-A\"]])\n\n          B515-A\nmin    -15.63437\nmax 262143.00000\n\n\nNotice that cs is left unchanged.\n\n\nAdding additional .fcs files to cytoset\nLastly, we can also add additional .fcs files to a cytoset using cs_add_cytoframe.\n\n# add to cytoset\ncs_small &lt;- realize_view(cs[1]) # cs[1] subsets cs into a cytoset while realize_view leads to a deep_copy into a new cytoset\ncs_small\n\nA cytoset with 1 samples.\n\n  column names:\n    FSC-A, FSC-H, SSC-A, B515-A, B610-A, B660-A, B710-A, B780-A, G575-A, G610-A, G660-A, G710-A, G780-A, R670-A, R730-A, R780-A, U390-A, U450-A, U500-A, U570-A, U660-A, U740-A, U785-A, V450-A, V510-A, V570-A, V605-A, V655-A, V710-A, V750-A, V785-A, remove_from_FS_FM, Time\n\n# no need to assign back to cs_small, because this function operates by reference and returns NULL anyways.\ncs_add_cytoframe(\n  cs = cs_small,\n  sn = \"Sample Name\",\n  cf = cs[[3]]   # cs[[3]] results in a cytoframe\n) \ncs_small\n\nA cytoset with 2 samples.\n\n  column names:\n    FSC-A, FSC-H, SSC-A, B515-A, B610-A, B660-A, B710-A, B780-A, G575-A, G610-A, G660-A, G710-A, G780-A, R670-A, R730-A, R780-A, U390-A, U450-A, U500-A, U570-A, U660-A, U740-A, U785-A, V450-A, V510-A, V570-A, V605-A, V655-A, V710-A, V750-A, V785-A, remove_from_FS_FM, Time\n\n\n\n\nFrom cytoset to cytoframe\nIt is possible that you may want to extract a cytoframe or extract all files as a list of cytoframe. We can either use [[]] to directly grab a cytoframe or cytoset_to_list.\n\n# extract a single cytoframe by using cs[[index/samplename]]\nsingle_cf &lt;- cs[[1]]\n\n# convert to a list\nlist_of_cf &lt;- cytoset_to_list(cs) \n\n\n\nList like operation with cytoset\nAs indicated previously, a cytoset behaves like a list. To leverage this behaviour we can use fsApply to iterate through the samples in a cytoset. By default, output is attempted to be coerced to a single array like object. (Set simplify = FALSE to return another list.)\n\n# getting number of rows (cells) of individual cytoframes\nn_cell_events &lt;- fsApply(cs, nrow)\nn_cell_events\n\n                   [,1]\n4000_BDC-CR1.fcs 912254\n4000_TNK-CR1.fcs 102015\n4001_BDC-CR1.fcs 924474\n4001_TNK-CR1.fcs  92703\n4002_TNK-CR1.fcs 372224\n4003_TNK-CR1.fcs 146150"
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#methods-for-conversion-between-cyto--and-flow--objects",
    "href": "vignettes/1_Import_fcs.html#methods-for-conversion-between-cyto--and-flow--objects",
    "title": "Basics of working with FCS files",
    "section": "Methods for conversion between cyto- and flow- objects",
    "text": "Methods for conversion between cyto- and flow- objects\n\n# convert a flowframe to cytoframe \nff_new &lt;- cytoframe_to_flowFrame(cf)\n\n# convert a cytoframe to flowframe \ncf_new &lt;- flowFrame_to_cytoframe(ff)\n\n# convert a flowset to cytoset \nfs_new &lt;- cytoset_to_flowSet(cs)\n\n# convert a cytoset to flowset \ncs_new &lt;- flowSet_to_cytoset(fs)"
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#saving-your-data",
    "href": "vignettes/1_Import_fcs.html#saving-your-data",
    "title": "Basics of working with FCS files",
    "section": "Saving your data",
    "text": "Saving your data\nSaving cyto- data is easy.\n\n# save cytoframe\ncf_write_disk(cf, \"path/to/my_new_cf\")\n\n# save cytoset\nsave_cytoset(cs, path = \"path/to/my/cs\")\n\nLoading it back is just as easy.\n\n# load cytoframe\nload_cytoframe(\"path/to/my_cf\")\n\n# load cytoset\nload_cytoset(\"path/to/my/cs\")\n\nWriting flow- data is easy.\n\n# write flowFrame\nwrite.FCS(ff, \"path/to/my_new_ff\")\n\n# write flowSet\nwrite.flowSet(fs, path = \"path/to/my/cs\")\n\nWe have previously discussed how to read FCS files into a flowFrame or flowSet objects."
  },
  {
    "objectID": "vignettes/1_Import_fcs.html#conclusion",
    "href": "vignettes/1_Import_fcs.html#conclusion",
    "title": "Basics of working with FCS files",
    "section": "Conclusion",
    "text": "Conclusion\nWe went through multiple ways to import, interact with, and manipulate .fcs files using the cytoverse tools. It is important to note additional functionality, which we will not going to go over at this workshop for the sake of time, for further manipulation and even creation of .fcs files exist with the cytoverse. We encourage you to explore them further at your leisure by calling browseVignettes(\"flowWorkspace\") and browseVignettes(\"flowCore\").\n\nThis workshop materials is adapted from CytoverseBioc 2023 workshop."
  },
  {
    "objectID": "vignettes/3_Gating_1.html",
    "href": "vignettes/3_Gating_1.html",
    "title": "Gating Cells in cytoverse - Part 1",
    "section": "",
    "text": "The purpose of flow cytometry is to make inferences regarding some cell type(s) of interest. Often this involves establishing/drawing a gating hierarchy to sequentially filter down to the cell type(s) of interest. This process is very often done manually, and can be very labour intensive. Importantly, manual approach implies large variation when one person does it vs. the next, or even if the same person does it multiple times. The cytoverse offers a suite of tools to tackle this problem in a reproducible and programmatic manner.\n\n\nIn the previous sections, we have seen (and worked with) cytoframe, and cytoset. These objects hold the underlying data, allowing us to visualize it, manipulate it, etc.\nIn this section we work with GatingSet and GatingHierarchy. These objects, like the name suggests, store information regarding various gates and filters that we will generate. Importantly, we can save the GatingSet which will completely package the analysis as well as the .fcs files in an opensource format that can be shared, allowing reproducibility.\nIn part 1 of this section, we will go over variety of native methods that exist in the cytoverse which analysts can utilize to gate their cells of interest.\nIn part 2 of this sections, we will go over methods to extract gated data for cells/populations of interest.\nIn part 3 (optional), we will demonstrate how analysts can automate this process by utilizing a gatingTemplate (a csv file that can be used to define and build the hierarchy).\n\n\n\nRequired libraries\n\nlibrary(flowWorkspace)\n\nWarning: package 'flowWorkspace' was built under R version 4.3.2\n\nlibrary(ggcyto)\n\nWarning: package 'ggcyto' was built under R version 4.3.2\n\nlibrary(openCyto)\n\nTo create a GatingSet, first load in a cytoset. Here, we are making use of the cytoset that we have created previously.\n\n# load cytoset\ncs &lt;- load_cytoset_from_fcs(path = \"data/fcs-data/\", pattern = \"*TNK*\")\nset.seed(20230725)\nmetadata &lt;- data.frame(name = sampleNames(cs),\n                       status = \"Healthy\", \n                       Treatment = sample(x = c(\"Treated\",\"Control\"), \n                                          size = length(cs), \n                                          prob = c(0.5,0.5),replace = TRUE), \n                       panel = ifelse(grepl(pattern = \"TNK\",x = sampleNames(cs)),\"T Cell Panel\",\"Myeloid Panel\"), \n                       row.names = sampleNames(cs))\n  \npData(cs) &lt;- metadata\n\n# creating a GatingSet\ngs &lt;- flowWorkspace::GatingSet(cs)\ngs\n\nA GatingSet with 4 samples\n\n\nWe have now created a GatingSet called gs.\n\n\n\nHow would you check the metadata associated with the GatingSet?\nHow would you subset gs to only include samples where Treatment = Control?\n\nThe GatingSet needs to be compensated and transformed before we start attaching gates.\nNote: The approach to compensate and transform a GatingSet is similar to that of cytoframe and cytoset; As such, we ask you to run the code below, up to line 125.\nWe can directly compensate the GatingSet object.\n\n# compensate a GatingSet\nspill &lt;- keyword(gs[[1]],\"$SPILLOVER\") # extract spillover matrix stored within the file\n\ngs &lt;- compensate(gs,spill) # GatingSet will be compensated and stores the spill matrix as well\n\nrecompute(gs) # update the gs\n\n# retrieve compensation information\ngs_spill &lt;- gs_get_compensations(gs[[1]])\n\n# output is a rich spillover information\nslot(gs_spill[[1]],\"spillover\")[1:4, 1:4]\n\n            B515-A     B610-A     B660-A      B710-A\nB515-A 1.000000000 0.07573059 0.04266579 0.003687143\nB610-A 0.009777704 1.00000000 0.78589800 0.074328487\nB660-A 0.005482375 0.03108691 1.00000000 0.112570733\nB710-A 0.024698965 0.12699130 0.90643808 1.000000000\n\n\nAs well we can transform the GatingSet.\nFor convenience, we are using a previously defined transformerList object. The transformerList object was extracted from the workspace file created by the authors of this study and can be found here.\n\n\n# transformation of GatingSet\nmy_trans &lt;- readRDS(file = \"data/fj-wsp/fj_transform.gz\")\n\n# make into transformerList object\nmy_trans_list &lt;- flowWorkspace::transformerList(\n  from = names(my_trans),\n  trans = my_trans\n)\n\ngs &lt;- flowWorkspace::transform(gs, my_trans_list) # transforms underlying data\n\n\n\n\n\n\nHow would you be able to tell if a GatingSet has been compensated?\nHow would be able to tell if a GatingSet has been transformed? Hint: Try help.search(\"get_transformation\").\nWhy might it be beneficial to compensate and transform a GatingSet rather than a cytoframe or a cytoset?\n\n\n\n\n\nYou may have noticed above that some function calls have gs_ and others have gh_.\ngs_ indicates that GatingSet while gh_ indicates a GatingHierarchy.\nThe GatingHierarchy is a data structure that stores the sample-wise gating information present in a GatingSet. In essence a GatingSet is a collection of GatingHierarchy.\nYou can access the GatingHierarchy using the [[ subset operation.\n\n\n\nTry running gh_get_compensations(gs). Why do you get an error message? How would you fix this?\nWhat other methods have gs_ and gh_?\nWhat is the difference between gs[1] and gs[[1]]?\nWhy are there multiple data structures to represent and hold flow cytometry data in the cytoverse?\n\n\n\n\n\nOn this GatingSet, we will add various gates that identifies cells of interest. Each sample within a GatingSet is associated with a GatingHierarchy that stores information regarding various gates that we would have created and applied to the samples.\nBelow, we demonstrate various types of gates that could be estimated automatically or be defined programmatically which can be applied to the samples within a GatingSet to build a hierarchy.\nNote: This process is informed by visualization of the data. As such, we will make ample use of the ggcyto library.\n\n\nThe gs_add_gating_method call from openCyto library can be leveraged for automatic estimation of gates, as well as clean scripting! Available gating methods can be listed by calling gt_list_methods(). Please see additional examples here: cytoverse.\nList of available methods.\n\n\nGating Functions:\n===  quantileGate \n===  gate_quantile \n===  rangeGate \n===  flowClust.2d \n===  gate_flowclust_2d \n===  mindensity \n===  gate_mindensity \n===  mindensity2 \n===  gate_mindensity2 \n===  cytokine \n===  flowClust.1d \n===  gate_flowclust_1d \n===  boundary \n===  singletGate \n===  quadGate.tmix \n===  gate_quad_tmix \n===  quadGate.seq \n===  gate_quad_sequential \nPreprocessing Functions:\n===  prior_flowClust \n===  prior_flowClust \n===  warpSet \n===  standardize_flowset \n\n\n\n\nA singlets gate is mostly used for data clean up, by removing out doublets.\n\n# visualization\nsinglet_vis &lt;- autoplot(\n  gs_pop_get_data(gs,\"root\"), # gs_pop_get_data(gs, node) extracts the underlying data\n  x = \"FSC-A\",\n  y = \"FSC-H\",\n  bins = 256\n  ) +\n  facet_wrap(~sampleNames(gs)\n  ) # leverage the metadata that is saved within the GatingSet to facet plots \nsinglet_vis\n\n\n\n\nNow, we estimate and add!\n\n# estimate and add\ngs_add_gating_method(\n  gs = gs, # gatingset\n  alias = \"singlets\", # name given to the population\n  pop = \"+\", # indicate whether events inside or outside the gate should be filtered\n  parent = \"root\", # where to attach this node\n  dims = \"FSC-A,FSC-H\", # dimensions used to estimate the gate\n  gating_method = \"singletGate\", # one of the available gating methods\n  gating_args = \"wider_gate = FALSE\", # arguments passed to singletGate\n)\n# visualize\nsinglet_vis + \n  geom_gate(\n    gs_pop_get_gate(\n      gs,\n      \"singlets\"\n    )\n  )+\n  facet_wrap(~name)\n\n\n\n\n\n\n\ngate_quantile and gate_mindensity2 can be used to estimate a cut point in the data, allowing the gating of data to the left(-) or the right(+) of the cut point.\n\n# calculate a live gate \n## Example of a quantile gate\n\n## visualize\nlive_viz &lt;- ggcyto(\n  gs,\n  subset = \"singlets\",\n  aes(x = \"Live\", y = \"FSC-A\")\n) +\ngeom_hex(bins = 128)+\nfacet_wrap(~name)\n# live_viz\n\n# add gate using gate_quantile\ngs_add_gating_method(\n  gs,\n  alias = \"live\",\n  pop = \"-\",\n  parent = \"singlets\",\n  dims = \"U450-A\",\n  gating_method = \"gate_quantile\",\n  gating_args = list(\n    probs = 0.95\n  )\n)\n\n# add gate using gate_mindensity2\ngs_add_gating_method(\n  gs,\n  alias = \"live_mindensity\",\n  pop = \"-\",\n  parent = \"singlets\",\n  dims = \"U450-A\",\n  gating_method = \"gate_mindensity2\",\n  gating_args = list(\n    max = 100, \n    gate_range = c(50, 75)\n  )\n)\n\n# visualize the 2 extimated gates\nlive_viz+\n  geom_gate(gs_pop_get_gate(gs, \"live\"), colour = \"red\")+\n  geom_gate(gs_pop_get_gate(gs, \"live_mindensity\"), colour = \"blue\")\n\n\n\n\nWe can also use the cutpoints to estimate a rectangular gate!\n\n# conventional T cells\nt_cell_vis &lt;- ggcyto(\n  gs, subset = \"live\",\n  aes(x  = \"TCR Va7_2\", y = \"CD161\")\n) + geom_hex(bins = 256)+\n  facet_wrap(~name)\n\n# visualize \n# t_cell_vis\n\n# estimate and add\ngs_add_gating_method(\n  gs,\n  alias = \"MAIT Cells\",\n  pop = \"++\",\n  parent = \"live\",\n  dims = \"G660-A,V710-A\",\n  gating_method = \"gate_quantile\",\n  gating_args = list(\n    probs = 0.95, \n    min = 50, \n    max = 200\n  )\n)\n\n...\n\n\ndone\n\n# visualize\nt_cell_vis+\n  geom_gate(gs_pop_get_gate(gs,\"MAIT Cells\"))\n\n\n\n\n\n\n\ngate_flowclust_2d can be used to identify and generate an Ellipsoid gate in a semi-supervised manner.\n\ncd3_ellipse &lt;- ggcyto(gs,\n       subset = \"live\",\n       aes(x = \"CD4\", y = \"CD3\"))+\n  geom_hex(bins = 256)\n\n# estimate and add\ngs_add_gating_method(\n  gs,\n  alias = \"CD3+\",\n  pop = \"+\",\n  parent = \"live\",\n  dims = \"U785-A,V510-A\",\n  gating_method = \"gate_flowclust_2d\",\n  gating_args = list(\n    K = 3,\n    target = c(100,150),\n    quantile = 0.9,\n    plot = FALSE\n  )\n)\n\n# visualize\ncd3_ellipse+\n  geom_gate(gs_pop_get_gate(gs,\"CD3+\"))\n\n\n\n\n\n\n\nHow would you add a gate called CD4+ T Cells defined as: CD4+ and CD3+?\nHint: Use the visualization above to provide an appropriate target.\ngating_args above indicates K = 3, quantile = 0.9, plot = FALSE. Try running the code block by indicating plot = TRUE. What is the outcome? How can you run this code block again? Hint: try running help.search(pattern = \"remove gating\").\n\n\n\n\n\nWhen there are population(s) of interest in all 4 quadrants, it is useful to estimate a quadrant gate using gate_quad_sequential. Note: Pay attention to alias and pop arguments!\n\n# plot subsets\nt_subsets &lt;- ggcyto(\n  gs,\n  subset = \"CD3+\",\n  aes(x = \"CD45RA\", y = \"CCR7\")\n)+\ngeom_hex(bins = 256)+\nfacet_wrap(~name)\n\n# visualize\n# t_subsets\n\n# estimate and add\ngs_add_gating_method(\n  gs,\n  alias = \"*\",\n  pop = \"+/-+/-\",\n  parent = \"CD3+\",\n  dims = \"CD45RA,CCR7\",\n  gating_method = \"gate_quad_sequential\",\n  gating_args = list(\n    gFunc = \"mindensity\"\n  ),\n  collapseDataForGating = TRUE\n)\n\n\n\n\nHow would you confirm that the attached gates have correct boundaries? Hint: Refer to the section on visualization.\nHow would you remove the gates attached by gs_add_gating_method? Hint: Try running help(gs_add_gating_method) and read the details.\n\ngs_remove_gating_method reverses the the results of gs_add_gating_method in a step wise manner.\n\nAre there other arguments for gs_add_gating_method? How can you use them?\n\nNote: gs_add_gating_method keeps a history of the calls made. If you reload a previously saved GatingSet via load_gs to work on, start with a clean history using gs_add_gating_method_init(gs) so that errors do not arise.\n\n\n\n\n\nSuppose you would like to add a gate that has a particular shape or range that cannot be easily estimated using the automatic estimation approaches above. In this case, you could programmatically define a gate by either providing ranges, coordinates, or logical statements as demonstrated below.\n\n\nAs the name suggests, we can explicitly define a rectangular gate by by defining a matrix where the columns are the ranges for markers in x-axis and y-axis. Only 1 dimension can also be provided. In this scenario, the constructed gate filter the events marginated over the dimension provided.\n\n## Example of rectangleGate\ncd3_vis &lt;- ggcyto(\n  gs, subset = \"root\", aes(x = \"CD3\", y = \"CD56\")\n)+\n  geom_hex(bins = 256)+\n  facet_wrap(~name)\n\n# before\n# cd3_vis\n\n# using rectangle gate to add T cell gate\ncd3_rectangle &lt;- matrix(\n  c(140, 205, 0, 200),\n  nrow = 2,\n  ncol = 2,\n  byrow = F,\n  dimnames = list(\n    c(\"min\", \"max\"), # rownames\n    c(\"V510-A\",\"U570-A\") # colnames are channel names\n  )\n) \ncd3_rectangle_gate &lt;- rectangleGate(\n  .gate = cd3_rectangle,\n  filterId = \"CD3+ T cells\"\n)\ncd3_vis+geom_gate(cd3_rectangle_gate)\n\n\n\n\nWhen a single dimension is provided:\n\n# provide the range\ncd3_range &lt;- matrix(data = c(140,200))\n# set the column name to the required channel\ncolnames(cd3_range) &lt;- \"V510-A\"\n\n# construct gate\ncd3_range_gate &lt;- rectangleGate(\n  .gate = cd3_range,\n  filterId = \"CD3+ Range\"\n) \n\ncd3_vis + geom_gate(cd3_range_gate)\n\n\n\n\nTo add this gate we call gs_pop_add like so:\n\ngs_pop_add(\n  gs,\n  parent = \"live\",\n  gate = cd3_range_gate\n)\n\n[1] 13\n\n\nEach call to gs_pop_add requires a recompute(gs) call.\n\n\n\nTry to run the following code:\n\n\n\nno_recompute &lt;- ggcyto(gs, \n       subset = \"CD3+ Range\",\n       aes(x = \"CD3\", y = \"CD4\"))+\n  geom_hex(bins = 256)\nno_recompute\n\n\nWhy do you get an error?\n\nWhile gs_add_pop attaches the gates to the GatingSet, the index of the filtered events are not calculated until you call recompute.\n\n\n\n\n\nSimilar to Rectangular gate we can define a Polygon gate by generating a matrix of vertices.\nHere, each row of the matrix is the coordinate for a vertex and the columns are the channels.\n\n## Example of polygonGate\nnkt_vis &lt;- ggcyto(gs, subset = \"root\",\n                  aes(x = \"CD1d\", y = \"CD3\"))+ # fuzzy matching of marker names\n  geom_hex(bins = 256)+\n  facet_wrap(~name)\n\nWarning in getChannelMarker(frm, dim): CD1d is partially matched with\nR670-ACD1d:PBS57 tet APC\n\n# visualize\n# nkt_vis\n\n# define coordinates\n## coordinates are based on visualization!\nnkt_poly &lt;- matrix(\n  c(\n    115,140, # are arranged as x,y pair\n    150,150,\n    150,180,\n    200,180,\n    200,140 \n  ), \n  ncol = 2,\n  byrow = T, # indicates that add as x,y pair\n  dimnames = list(\n    NULL, # rownames have no meaning in polygonGates\n    c(\"R670-A\",\"V510-A\") # colnames are channel names\n  ) \n)\n\n# create a gate\nnkt_poly_gate &lt;- polygonGate(\n  nkt_poly,\n  filterId = \"NKT cells\"\n)\n# visualize\nnkt_vis + geom_gate(nkt_poly_gate)\n\n\n\n\nEditing a gate after construction is straight forward.\n\n# move up and scale\nnkt_poly_gate_scale &lt;- flowCore::transform_gate(\n  nkt_poly_gate, # gate object\n  dx = 1, # which dimension to shift and by how much\n                                        # dy = 1,\n                                        # scale = 2 # scales both dimensions equally\n  scale = c(1.05,1.05) # individually scale each dimension\n)\nnkt_vis+geom_gate(nkt_poly_gate_scale)\n\n\n\n\n\n\n\nConstruct a new Rectangular gate that can be used to filter CD4- CD3+ population. Hint: Visualize the data and then define the best ranges.\nHow would you rotate this gate? Hint: try running help(flowCore::transform_gate).\nThink back to the CD3+ gate we created using gs_add_gating_method, how would you edit it? Hint: try running help.search(\"get or set gate\").\n\n\n\n\n\nWe can use booleanFilter to simply negate a gated population! The resulting filter does not have a geometric representation.\n\n# add not MAIT gate\n## Example of booleanFilter\nnot_mait &lt;- booleanFilter(`!MAIT Cells`, filterId = \"not_MAIT\")\n\n# add Boolean gate\ngs_pop_add(\n  gs, \n  not_mait, \n  parent = \"live\"\n)\n\n[1] 14\n\nrecompute(gs)\n\n# visualize\nt_cell_vis+\n  geom_overlay(\n    gs_pop_get_data(gs, y = \"not_MAIT\"),\n    size = 0.3, \n    colour = \"red\"\n  )\n\n\n\n\nNote: We are also able to combine multiple gates to generate a booleanFilter.\nLet’s create by combining not_MAIT and MAIT Cells\n\n# using an OR ('|') operator\nall_cells &lt;- booleanFilter(\n  `not_MAIT|MAIT Cells`,\n  filterId = \"All\"\n)\n# add population\ngs_pop_add(gs, all_cells, parent = \"live\")\nrecompute(gs)\n\n\n\n\n\nHow would you create a booleanFilter that only filters out naive T cells defined as CD45RA+CCR7+? Can you visualize the result?\nHow would you remove the gate called All?\nHow would you remove an attached gate? Is recompute required after removal of a gate?\nWhat happens if you remove a parent gate?\n\n\n\n\n\n\nWe have been creating and adding many gates to our GatingSet. A useful way to visualize all the gates and their relationship is by plotting the gating Hierarchy as a tree. This gives us an immediate summary of what nodes are present in our GatingSet.\n\n# plot the gating tree\nplot(gs, bool = TRUE)\n\n\n\n\nAnother useful approach is to visualize the gated data, with gates that we have generated. See the section of visualization for more.\n\n# visualize the full gating hierarchy\nautoplot(\n  gs[[1]],\n  bins = 256, \n  bool = TRUE)+\n  ggcyto_par_set(limits = \"data\") # set data range to be determined by data\n\n\n\n\n\n\n\nFinally, we save your GatingSet. The GatingSet can be loaded back into R using load_gs(\"path/to/a/folder\").\n\n# save your work\nsave_gs(gs, path = \"path/to/a/folder\")\n\n\n\n\nIn this section, we spent some time identifying various types of gates that are available in cytoverse. As well, we demonstrated how to programmatically create such gates, either manually (i.e. by defining ranges or vertices) or in a semi-automated and data driven manner.\nNext, we go over methods to extract the gated data.\nThe (Optional) Part 3 goes over how users can leverage a gatingTemplate to generate gates as we have done here, but with minimal scripting. It is worth noting that while the use gatingTemplate minimizes scripting, it does not compromise on reproducibility!\nLastly, we also made ample use of the ggcyto library in order to generate visualizations that helped in QC’ing the data and the gates that we generated. We will go over ggcyto in more detail in Visualizations."
  },
  {
    "objectID": "vignettes/3_Gating_1.html#gatingset-and-gatingheirarchy",
    "href": "vignettes/3_Gating_1.html#gatingset-and-gatingheirarchy",
    "title": "Gating Cells in cytoverse - Part 1",
    "section": "",
    "text": "In the previous sections, we have seen (and worked with) cytoframe, and cytoset. These objects hold the underlying data, allowing us to visualize it, manipulate it, etc.\nIn this section we work with GatingSet and GatingHierarchy. These objects, like the name suggests, store information regarding various gates and filters that we will generate. Importantly, we can save the GatingSet which will completely package the analysis as well as the .fcs files in an opensource format that can be shared, allowing reproducibility.\nIn part 1 of this section, we will go over variety of native methods that exist in the cytoverse which analysts can utilize to gate their cells of interest.\nIn part 2 of this sections, we will go over methods to extract gated data for cells/populations of interest.\nIn part 3 (optional), we will demonstrate how analysts can automate this process by utilizing a gatingTemplate (a csv file that can be used to define and build the hierarchy)."
  },
  {
    "objectID": "vignettes/3_Gating_1.html#creating-a-gatingset",
    "href": "vignettes/3_Gating_1.html#creating-a-gatingset",
    "title": "Gating Cells in cytoverse - Part 1",
    "section": "",
    "text": "Required libraries\n\nlibrary(flowWorkspace)\n\nWarning: package 'flowWorkspace' was built under R version 4.3.2\n\nlibrary(ggcyto)\n\nWarning: package 'ggcyto' was built under R version 4.3.2\n\nlibrary(openCyto)\n\nTo create a GatingSet, first load in a cytoset. Here, we are making use of the cytoset that we have created previously.\n\n# load cytoset\ncs &lt;- load_cytoset_from_fcs(path = \"data/fcs-data/\", pattern = \"*TNK*\")\nset.seed(20230725)\nmetadata &lt;- data.frame(name = sampleNames(cs),\n                       status = \"Healthy\", \n                       Treatment = sample(x = c(\"Treated\",\"Control\"), \n                                          size = length(cs), \n                                          prob = c(0.5,0.5),replace = TRUE), \n                       panel = ifelse(grepl(pattern = \"TNK\",x = sampleNames(cs)),\"T Cell Panel\",\"Myeloid Panel\"), \n                       row.names = sampleNames(cs))\n  \npData(cs) &lt;- metadata\n\n# creating a GatingSet\ngs &lt;- flowWorkspace::GatingSet(cs)\ngs\n\nA GatingSet with 4 samples\n\n\nWe have now created a GatingSet called gs.\n\n\n\nHow would you check the metadata associated with the GatingSet?\nHow would you subset gs to only include samples where Treatment = Control?\n\nThe GatingSet needs to be compensated and transformed before we start attaching gates.\nNote: The approach to compensate and transform a GatingSet is similar to that of cytoframe and cytoset; As such, we ask you to run the code below, up to line 125.\nWe can directly compensate the GatingSet object.\n\n# compensate a GatingSet\nspill &lt;- keyword(gs[[1]],\"$SPILLOVER\") # extract spillover matrix stored within the file\n\ngs &lt;- compensate(gs,spill) # GatingSet will be compensated and stores the spill matrix as well\n\nrecompute(gs) # update the gs\n\n# retrieve compensation information\ngs_spill &lt;- gs_get_compensations(gs[[1]])\n\n# output is a rich spillover information\nslot(gs_spill[[1]],\"spillover\")[1:4, 1:4]\n\n            B515-A     B610-A     B660-A      B710-A\nB515-A 1.000000000 0.07573059 0.04266579 0.003687143\nB610-A 0.009777704 1.00000000 0.78589800 0.074328487\nB660-A 0.005482375 0.03108691 1.00000000 0.112570733\nB710-A 0.024698965 0.12699130 0.90643808 1.000000000\n\n\nAs well we can transform the GatingSet.\nFor convenience, we are using a previously defined transformerList object. The transformerList object was extracted from the workspace file created by the authors of this study and can be found here.\n\n\n# transformation of GatingSet\nmy_trans &lt;- readRDS(file = \"data/fj-wsp/fj_transform.gz\")\n\n# make into transformerList object\nmy_trans_list &lt;- flowWorkspace::transformerList(\n  from = names(my_trans),\n  trans = my_trans\n)\n\ngs &lt;- flowWorkspace::transform(gs, my_trans_list) # transforms underlying data\n\n\n\n\n\n\nHow would you be able to tell if a GatingSet has been compensated?\nHow would be able to tell if a GatingSet has been transformed? Hint: Try help.search(\"get_transformation\").\nWhy might it be beneficial to compensate and transform a GatingSet rather than a cytoframe or a cytoset?"
  },
  {
    "objectID": "vignettes/3_Gating_1.html#a-note-about-gatinghierarchy",
    "href": "vignettes/3_Gating_1.html#a-note-about-gatinghierarchy",
    "title": "Gating Cells in cytoverse - Part 1",
    "section": "",
    "text": "You may have noticed above that some function calls have gs_ and others have gh_.\ngs_ indicates that GatingSet while gh_ indicates a GatingHierarchy.\nThe GatingHierarchy is a data structure that stores the sample-wise gating information present in a GatingSet. In essence a GatingSet is a collection of GatingHierarchy.\nYou can access the GatingHierarchy using the [[ subset operation.\n\n\n\nTry running gh_get_compensations(gs). Why do you get an error message? How would you fix this?\nWhat other methods have gs_ and gh_?\nWhat is the difference between gs[1] and gs[[1]]?\nWhy are there multiple data structures to represent and hold flow cytometry data in the cytoverse?"
  },
  {
    "objectID": "vignettes/3_Gating_1.html#adding-gates-and-building-a-hierarchy",
    "href": "vignettes/3_Gating_1.html#adding-gates-and-building-a-hierarchy",
    "title": "Gating Cells in cytoverse - Part 1",
    "section": "",
    "text": "On this GatingSet, we will add various gates that identifies cells of interest. Each sample within a GatingSet is associated with a GatingHierarchy that stores information regarding various gates that we would have created and applied to the samples.\nBelow, we demonstrate various types of gates that could be estimated automatically or be defined programmatically which can be applied to the samples within a GatingSet to build a hierarchy.\nNote: This process is informed by visualization of the data. As such, we will make ample use of the ggcyto library.\n\n\nThe gs_add_gating_method call from openCyto library can be leveraged for automatic estimation of gates, as well as clean scripting! Available gating methods can be listed by calling gt_list_methods(). Please see additional examples here: cytoverse.\nList of available methods.\n\n\nGating Functions:\n===  quantileGate \n===  gate_quantile \n===  rangeGate \n===  flowClust.2d \n===  gate_flowclust_2d \n===  mindensity \n===  gate_mindensity \n===  mindensity2 \n===  gate_mindensity2 \n===  cytokine \n===  flowClust.1d \n===  gate_flowclust_1d \n===  boundary \n===  singletGate \n===  quadGate.tmix \n===  gate_quad_tmix \n===  quadGate.seq \n===  gate_quad_sequential \nPreprocessing Functions:\n===  prior_flowClust \n===  prior_flowClust \n===  warpSet \n===  standardize_flowset \n\n\n\n\nA singlets gate is mostly used for data clean up, by removing out doublets.\n\n# visualization\nsinglet_vis &lt;- autoplot(\n  gs_pop_get_data(gs,\"root\"), # gs_pop_get_data(gs, node) extracts the underlying data\n  x = \"FSC-A\",\n  y = \"FSC-H\",\n  bins = 256\n  ) +\n  facet_wrap(~sampleNames(gs)\n  ) # leverage the metadata that is saved within the GatingSet to facet plots \nsinglet_vis\n\n\n\n\nNow, we estimate and add!\n\n# estimate and add\ngs_add_gating_method(\n  gs = gs, # gatingset\n  alias = \"singlets\", # name given to the population\n  pop = \"+\", # indicate whether events inside or outside the gate should be filtered\n  parent = \"root\", # where to attach this node\n  dims = \"FSC-A,FSC-H\", # dimensions used to estimate the gate\n  gating_method = \"singletGate\", # one of the available gating methods\n  gating_args = \"wider_gate = FALSE\", # arguments passed to singletGate\n)\n# visualize\nsinglet_vis + \n  geom_gate(\n    gs_pop_get_gate(\n      gs,\n      \"singlets\"\n    )\n  )+\n  facet_wrap(~name)\n\n\n\n\n\n\n\ngate_quantile and gate_mindensity2 can be used to estimate a cut point in the data, allowing the gating of data to the left(-) or the right(+) of the cut point.\n\n# calculate a live gate \n## Example of a quantile gate\n\n## visualize\nlive_viz &lt;- ggcyto(\n  gs,\n  subset = \"singlets\",\n  aes(x = \"Live\", y = \"FSC-A\")\n) +\ngeom_hex(bins = 128)+\nfacet_wrap(~name)\n# live_viz\n\n# add gate using gate_quantile\ngs_add_gating_method(\n  gs,\n  alias = \"live\",\n  pop = \"-\",\n  parent = \"singlets\",\n  dims = \"U450-A\",\n  gating_method = \"gate_quantile\",\n  gating_args = list(\n    probs = 0.95\n  )\n)\n\n# add gate using gate_mindensity2\ngs_add_gating_method(\n  gs,\n  alias = \"live_mindensity\",\n  pop = \"-\",\n  parent = \"singlets\",\n  dims = \"U450-A\",\n  gating_method = \"gate_mindensity2\",\n  gating_args = list(\n    max = 100, \n    gate_range = c(50, 75)\n  )\n)\n\n# visualize the 2 extimated gates\nlive_viz+\n  geom_gate(gs_pop_get_gate(gs, \"live\"), colour = \"red\")+\n  geom_gate(gs_pop_get_gate(gs, \"live_mindensity\"), colour = \"blue\")\n\n\n\n\nWe can also use the cutpoints to estimate a rectangular gate!\n\n# conventional T cells\nt_cell_vis &lt;- ggcyto(\n  gs, subset = \"live\",\n  aes(x  = \"TCR Va7_2\", y = \"CD161\")\n) + geom_hex(bins = 256)+\n  facet_wrap(~name)\n\n# visualize \n# t_cell_vis\n\n# estimate and add\ngs_add_gating_method(\n  gs,\n  alias = \"MAIT Cells\",\n  pop = \"++\",\n  parent = \"live\",\n  dims = \"G660-A,V710-A\",\n  gating_method = \"gate_quantile\",\n  gating_args = list(\n    probs = 0.95, \n    min = 50, \n    max = 200\n  )\n)\n\n...\n\n\ndone\n\n# visualize\nt_cell_vis+\n  geom_gate(gs_pop_get_gate(gs,\"MAIT Cells\"))\n\n\n\n\n\n\n\ngate_flowclust_2d can be used to identify and generate an Ellipsoid gate in a semi-supervised manner.\n\ncd3_ellipse &lt;- ggcyto(gs,\n       subset = \"live\",\n       aes(x = \"CD4\", y = \"CD3\"))+\n  geom_hex(bins = 256)\n\n# estimate and add\ngs_add_gating_method(\n  gs,\n  alias = \"CD3+\",\n  pop = \"+\",\n  parent = \"live\",\n  dims = \"U785-A,V510-A\",\n  gating_method = \"gate_flowclust_2d\",\n  gating_args = list(\n    K = 3,\n    target = c(100,150),\n    quantile = 0.9,\n    plot = FALSE\n  )\n)\n\n# visualize\ncd3_ellipse+\n  geom_gate(gs_pop_get_gate(gs,\"CD3+\"))\n\n\n\n\n\n\n\nHow would you add a gate called CD4+ T Cells defined as: CD4+ and CD3+?\nHint: Use the visualization above to provide an appropriate target.\ngating_args above indicates K = 3, quantile = 0.9, plot = FALSE. Try running the code block by indicating plot = TRUE. What is the outcome? How can you run this code block again? Hint: try running help.search(pattern = \"remove gating\").\n\n\n\n\n\nWhen there are population(s) of interest in all 4 quadrants, it is useful to estimate a quadrant gate using gate_quad_sequential. Note: Pay attention to alias and pop arguments!\n\n# plot subsets\nt_subsets &lt;- ggcyto(\n  gs,\n  subset = \"CD3+\",\n  aes(x = \"CD45RA\", y = \"CCR7\")\n)+\ngeom_hex(bins = 256)+\nfacet_wrap(~name)\n\n# visualize\n# t_subsets\n\n# estimate and add\ngs_add_gating_method(\n  gs,\n  alias = \"*\",\n  pop = \"+/-+/-\",\n  parent = \"CD3+\",\n  dims = \"CD45RA,CCR7\",\n  gating_method = \"gate_quad_sequential\",\n  gating_args = list(\n    gFunc = \"mindensity\"\n  ),\n  collapseDataForGating = TRUE\n)\n\n\n\n\nHow would you confirm that the attached gates have correct boundaries? Hint: Refer to the section on visualization.\nHow would you remove the gates attached by gs_add_gating_method? Hint: Try running help(gs_add_gating_method) and read the details.\n\ngs_remove_gating_method reverses the the results of gs_add_gating_method in a step wise manner.\n\nAre there other arguments for gs_add_gating_method? How can you use them?\n\nNote: gs_add_gating_method keeps a history of the calls made. If you reload a previously saved GatingSet via load_gs to work on, start with a clean history using gs_add_gating_method_init(gs) so that errors do not arise.\n\n\n\n\n\nSuppose you would like to add a gate that has a particular shape or range that cannot be easily estimated using the automatic estimation approaches above. In this case, you could programmatically define a gate by either providing ranges, coordinates, or logical statements as demonstrated below.\n\n\nAs the name suggests, we can explicitly define a rectangular gate by by defining a matrix where the columns are the ranges for markers in x-axis and y-axis. Only 1 dimension can also be provided. In this scenario, the constructed gate filter the events marginated over the dimension provided.\n\n## Example of rectangleGate\ncd3_vis &lt;- ggcyto(\n  gs, subset = \"root\", aes(x = \"CD3\", y = \"CD56\")\n)+\n  geom_hex(bins = 256)+\n  facet_wrap(~name)\n\n# before\n# cd3_vis\n\n# using rectangle gate to add T cell gate\ncd3_rectangle &lt;- matrix(\n  c(140, 205, 0, 200),\n  nrow = 2,\n  ncol = 2,\n  byrow = F,\n  dimnames = list(\n    c(\"min\", \"max\"), # rownames\n    c(\"V510-A\",\"U570-A\") # colnames are channel names\n  )\n) \ncd3_rectangle_gate &lt;- rectangleGate(\n  .gate = cd3_rectangle,\n  filterId = \"CD3+ T cells\"\n)\ncd3_vis+geom_gate(cd3_rectangle_gate)\n\n\n\n\nWhen a single dimension is provided:\n\n# provide the range\ncd3_range &lt;- matrix(data = c(140,200))\n# set the column name to the required channel\ncolnames(cd3_range) &lt;- \"V510-A\"\n\n# construct gate\ncd3_range_gate &lt;- rectangleGate(\n  .gate = cd3_range,\n  filterId = \"CD3+ Range\"\n) \n\ncd3_vis + geom_gate(cd3_range_gate)\n\n\n\n\nTo add this gate we call gs_pop_add like so:\n\ngs_pop_add(\n  gs,\n  parent = \"live\",\n  gate = cd3_range_gate\n)\n\n[1] 13\n\n\nEach call to gs_pop_add requires a recompute(gs) call.\n\n\n\nTry to run the following code:\n\n\n\nno_recompute &lt;- ggcyto(gs, \n       subset = \"CD3+ Range\",\n       aes(x = \"CD3\", y = \"CD4\"))+\n  geom_hex(bins = 256)\nno_recompute\n\n\nWhy do you get an error?\n\nWhile gs_add_pop attaches the gates to the GatingSet, the index of the filtered events are not calculated until you call recompute.\n\n\n\n\n\nSimilar to Rectangular gate we can define a Polygon gate by generating a matrix of vertices.\nHere, each row of the matrix is the coordinate for a vertex and the columns are the channels.\n\n## Example of polygonGate\nnkt_vis &lt;- ggcyto(gs, subset = \"root\",\n                  aes(x = \"CD1d\", y = \"CD3\"))+ # fuzzy matching of marker names\n  geom_hex(bins = 256)+\n  facet_wrap(~name)\n\nWarning in getChannelMarker(frm, dim): CD1d is partially matched with\nR670-ACD1d:PBS57 tet APC\n\n# visualize\n# nkt_vis\n\n# define coordinates\n## coordinates are based on visualization!\nnkt_poly &lt;- matrix(\n  c(\n    115,140, # are arranged as x,y pair\n    150,150,\n    150,180,\n    200,180,\n    200,140 \n  ), \n  ncol = 2,\n  byrow = T, # indicates that add as x,y pair\n  dimnames = list(\n    NULL, # rownames have no meaning in polygonGates\n    c(\"R670-A\",\"V510-A\") # colnames are channel names\n  ) \n)\n\n# create a gate\nnkt_poly_gate &lt;- polygonGate(\n  nkt_poly,\n  filterId = \"NKT cells\"\n)\n# visualize\nnkt_vis + geom_gate(nkt_poly_gate)\n\n\n\n\nEditing a gate after construction is straight forward.\n\n# move up and scale\nnkt_poly_gate_scale &lt;- flowCore::transform_gate(\n  nkt_poly_gate, # gate object\n  dx = 1, # which dimension to shift and by how much\n                                        # dy = 1,\n                                        # scale = 2 # scales both dimensions equally\n  scale = c(1.05,1.05) # individually scale each dimension\n)\nnkt_vis+geom_gate(nkt_poly_gate_scale)\n\n\n\n\n\n\n\nConstruct a new Rectangular gate that can be used to filter CD4- CD3+ population. Hint: Visualize the data and then define the best ranges.\nHow would you rotate this gate? Hint: try running help(flowCore::transform_gate).\nThink back to the CD3+ gate we created using gs_add_gating_method, how would you edit it? Hint: try running help.search(\"get or set gate\").\n\n\n\n\n\nWe can use booleanFilter to simply negate a gated population! The resulting filter does not have a geometric representation.\n\n# add not MAIT gate\n## Example of booleanFilter\nnot_mait &lt;- booleanFilter(`!MAIT Cells`, filterId = \"not_MAIT\")\n\n# add Boolean gate\ngs_pop_add(\n  gs, \n  not_mait, \n  parent = \"live\"\n)\n\n[1] 14\n\nrecompute(gs)\n\n# visualize\nt_cell_vis+\n  geom_overlay(\n    gs_pop_get_data(gs, y = \"not_MAIT\"),\n    size = 0.3, \n    colour = \"red\"\n  )\n\n\n\n\nNote: We are also able to combine multiple gates to generate a booleanFilter.\nLet’s create by combining not_MAIT and MAIT Cells\n\n# using an OR ('|') operator\nall_cells &lt;- booleanFilter(\n  `not_MAIT|MAIT Cells`,\n  filterId = \"All\"\n)\n# add population\ngs_pop_add(gs, all_cells, parent = \"live\")\nrecompute(gs)\n\n\n\n\n\nHow would you create a booleanFilter that only filters out naive T cells defined as CD45RA+CCR7+? Can you visualize the result?\nHow would you remove the gate called All?\nHow would you remove an attached gate? Is recompute required after removal of a gate?\nWhat happens if you remove a parent gate?"
  },
  {
    "objectID": "vignettes/3_Gating_1.html#visualizing-the-gating-hierachy",
    "href": "vignettes/3_Gating_1.html#visualizing-the-gating-hierachy",
    "title": "Gating Cells in cytoverse - Part 1",
    "section": "",
    "text": "We have been creating and adding many gates to our GatingSet. A useful way to visualize all the gates and their relationship is by plotting the gating Hierarchy as a tree. This gives us an immediate summary of what nodes are present in our GatingSet.\n\n# plot the gating tree\nplot(gs, bool = TRUE)\n\n\n\n\nAnother useful approach is to visualize the gated data, with gates that we have generated. See the section of visualization for more.\n\n# visualize the full gating hierarchy\nautoplot(\n  gs[[1]],\n  bins = 256, \n  bool = TRUE)+\n  ggcyto_par_set(limits = \"data\") # set data range to be determined by data"
  },
  {
    "objectID": "vignettes/3_Gating_1.html#saving-your-work",
    "href": "vignettes/3_Gating_1.html#saving-your-work",
    "title": "Gating Cells in cytoverse - Part 1",
    "section": "",
    "text": "Finally, we save your GatingSet. The GatingSet can be loaded back into R using load_gs(\"path/to/a/folder\").\n\n# save your work\nsave_gs(gs, path = \"path/to/a/folder\")"
  },
  {
    "objectID": "vignettes/3_Gating_1.html#conclusion",
    "href": "vignettes/3_Gating_1.html#conclusion",
    "title": "Gating Cells in cytoverse - Part 1",
    "section": "",
    "text": "In this section, we spent some time identifying various types of gates that are available in cytoverse. As well, we demonstrated how to programmatically create such gates, either manually (i.e. by defining ranges or vertices) or in a semi-automated and data driven manner.\nNext, we go over methods to extract the gated data.\nThe (Optional) Part 3 goes over how users can leverage a gatingTemplate to generate gates as we have done here, but with minimal scripting. It is worth noting that while the use gatingTemplate minimizes scripting, it does not compromise on reproducibility!\nLastly, we also made ample use of the ggcyto library in order to generate visualizations that helped in QC’ing the data and the gates that we generated. We will go over ggcyto in more detail in Visualizations."
  },
  {
    "objectID": "vignettes/4_Gating_2.html",
    "href": "vignettes/4_Gating_2.html",
    "title": "Gating cells in cytoverse - Part 2",
    "section": "",
    "text": "In this section we describe the methods available to access and extract the gated data within a GatingSet. It is important to note here that the gates essentially act as filter for the data and may be utilize to subset the original data.\n\nlibrary(flowWorkspace)\n\nWarning: package 'flowWorkspace' was built under R version 4.3.2\n\nlibrary(flowCore)\n\n\n\nLet’s first look at the gates that are attached to the GatingSet. For this example, we will make use of a GatingSet that we have previously prepared.\n\nsource(\"make_transformed_gs_func.R\")\ngs &lt;- make_transformed_gs(add_gates = TRUE)\ngs\n\nA GatingSet with 4 samples\n\n\nWe have previously used plot(gs) to visualize the gating hierarchy as a tree as shown below:\n\n\n\n\n\nTo extract the full gating path we can use gs_get_pop_paths method.\n\n# get all paths\ngs_get_pop_paths(gs)\n\n [1] \"root\"                                                                                       \n [2] \"/singlet\"                                                                                   \n [3] \"/singlet/live\"                                                                              \n [4] \"/singlet/live/lymphocytes\"                                                                  \n [5] \"/singlet/live/lymphocytes/CD3+ T cells\"                                                     \n [6] \"/singlet/live/lymphocytes/CD3+ T cells/NKT cells\"                                           \n [7] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells\"                                       \n [8] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells\"                           \n [9] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\"                \n[10] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\"                  \n[11] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon\"          \n[12] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\"\n[13] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\"\n[14] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\"\n[15] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a-\"\n\n\nWhen there are a lot of gates, this list can become very long as each node is shown as a distinct path. Suppose you would like to only view the leaf nodes. For this, we use gs_get_leaf_nodes.\n\n# get leaf nodes\ngs_get_leaf_nodes(\n  gs, \n  ancestor = \"root\") # can select leafs of a specific node\n\n[1] \"/singlet/live/lymphocytes/CD3+ T cells/NKT cells\"                                           \n[2] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\"                \n[3] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\"                  \n[4] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\"\n[5] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\"\n[6] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\"\n[7] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a-\"\n\n\nTo change the name of a node, for instance, CD4-CD8a- above is not super clear and we want to update this to Double Negative CD3+ T cells for readability, we can use gs_pop_set_name method.\n\n# rename node\ngs_pop_set_name(\n  gs,\n  \"CD4-CD8a-\",\n  \"Double Negative CD3+ T cells\")\n\n$`4000_TNK-CR1`\nNULL\n\n$`4001_TNK-CR1`\nNULL\n\n$`4002_TNK-CR1`\nNULL\n\n$`4003_TNK-CR1`\nNULL\n\n# check\ngs_get_leaf_nodes(gs)\n\n[1] \"/singlet/live/lymphocytes/CD3+ T cells/NKT cells\"                                                              \n[2] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\"                                   \n[3] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\"                                     \n[4] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\"                   \n[5] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\"                   \n[6] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\"                   \n[7] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/Double Negative CD3+ T cells\"\n\n\n\n\n\nRun gs_get_pop_paths(gs) by include a path = 1 argument. How is the output different compared to not providing path? What happens when you change this to path = 2?\nSuppose you do not know what is the parent population for Double Negative CD3+ T cells, what is an easy approach to get this information? Hint: Try help(gs_pop_get_paths) to check other available methods.\n\n\n\n\n\nOften, users may also want to extract the embedded expression data for a specified gated population for some downstream application. The cytoverse makes it super easy to extract this data. Moreover, the extracted data is preserved as a cytoframe or a cytoset for ease of use.\nThe 2 main methods are: 1. gs_pop_get_data 2. gh_pop_get_data\n\n# extract data\nextracted &lt;- gs_pop_get_data(gs,\n                y = \"live\",\n                inverse.transform = FALSE)\nextracted\n\nA cytoset with 4 samples.\n\n  column names:\n    FSC-A, FSC-H, SSC-A, B515-A, B610-A, B660-A, B710-A, B780-A, G575-A, G610-A, G660-A, G710-A, G780-A, R670-A, R730-A, R780-A, U390-A, U450-A, U500-A, U570-A, U660-A, U740-A, U785-A, V450-A, V510-A, V570-A, V605-A, V655-A, V710-A, V750-A, V785-A, remove_from_FS_FM, Time\n\ncytoset has been subsetted and can be realized through 'realize_view()'.\n\n\n\n\n\nTry running the above code as gh_pop_get_data. How are the results different?\nExtract the data from the gate Double Negative CD3+ T cells for the 1st sample and store it as sample_1. Transform the expression value for FSC-A. What happens to the data in gs?Hint\n\n\n# plot\nggcyto(gs,\n       subset = \"Double Negative CD3+ T cells\", \n       aes(x = \"FSC-A\", y = \"SSC-A\"))+\n  geom_hex(bins = 256)\nNotice that altering the extracted data leads to altered data within the GatingSet. This is because we did not create a new copy of the data using realize_view method. Importantly, this further highlights that the cytoframe, cytoset, and the GatingSet are all pointing to the same data!\n\n\nwhat does inverse.transform argument do?\nRun the following code:\n\n\nThis is only for example.\n\nanother_CD3_gate &lt;- matrix(c(-Inf,Inf), nrow = 2, ncol=1)\ncolnames(another_CD3_gate) &lt;- \"FSC-A\"\nanother_CD3_gate &lt;- rectangleGate(.gate = another_CD3_gate, filterId = \"CD3+ T cells\")\ngs_pop_add(gs, parent = \"non-NKT Cells\", gate = another_CD3_gate)\nrecompute(gs)\nplot(gs)\n\n\nNow try to extract the CD3+ T cells population using either gs_ or gh_ methods as above.\n\n\n\n\nDepending on the method called, the extracted data is either preserved as a cytoframe or a cytoset. As you experienced in the exercise, manipulating the extracted without performing a deep copy using realize_view leads to alteration of the data within the GatingSet object. As such, if extracting for further downstream application, it maybe worthwhile to save the data. For this, please refer to the Importing and Basics of working with FCS files for more details."
  },
  {
    "objectID": "vignettes/4_Gating_2.html#gating-paths-get-and-set",
    "href": "vignettes/4_Gating_2.html#gating-paths-get-and-set",
    "title": "Gating cells in cytoverse - Part 2",
    "section": "",
    "text": "Let’s first look at the gates that are attached to the GatingSet. For this example, we will make use of a GatingSet that we have previously prepared.\n\nsource(\"make_transformed_gs_func.R\")\ngs &lt;- make_transformed_gs(add_gates = TRUE)\ngs\n\nA GatingSet with 4 samples\n\n\nWe have previously used plot(gs) to visualize the gating hierarchy as a tree as shown below:\n\n\n\n\n\nTo extract the full gating path we can use gs_get_pop_paths method.\n\n# get all paths\ngs_get_pop_paths(gs)\n\n [1] \"root\"                                                                                       \n [2] \"/singlet\"                                                                                   \n [3] \"/singlet/live\"                                                                              \n [4] \"/singlet/live/lymphocytes\"                                                                  \n [5] \"/singlet/live/lymphocytes/CD3+ T cells\"                                                     \n [6] \"/singlet/live/lymphocytes/CD3+ T cells/NKT cells\"                                           \n [7] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells\"                                       \n [8] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells\"                           \n [9] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\"                \n[10] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\"                  \n[11] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon\"          \n[12] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\"\n[13] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\"\n[14] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\"\n[15] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a-\"\n\n\nWhen there are a lot of gates, this list can become very long as each node is shown as a distinct path. Suppose you would like to only view the leaf nodes. For this, we use gs_get_leaf_nodes.\n\n# get leaf nodes\ngs_get_leaf_nodes(\n  gs, \n  ancestor = \"root\") # can select leafs of a specific node\n\n[1] \"/singlet/live/lymphocytes/CD3+ T cells/NKT cells\"                                           \n[2] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\"                \n[3] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\"                  \n[4] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\"\n[5] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\"\n[6] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\"\n[7] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a-\"\n\n\nTo change the name of a node, for instance, CD4-CD8a- above is not super clear and we want to update this to Double Negative CD3+ T cells for readability, we can use gs_pop_set_name method.\n\n# rename node\ngs_pop_set_name(\n  gs,\n  \"CD4-CD8a-\",\n  \"Double Negative CD3+ T cells\")\n\n$`4000_TNK-CR1`\nNULL\n\n$`4001_TNK-CR1`\nNULL\n\n$`4002_TNK-CR1`\nNULL\n\n$`4003_TNK-CR1`\nNULL\n\n# check\ngs_get_leaf_nodes(gs)\n\n[1] \"/singlet/live/lymphocytes/CD3+ T cells/NKT cells\"                                                              \n[2] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/MAIT Cells\"                                   \n[3] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT\"                                     \n[4] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4-CD8a+\"                   \n[5] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a+\"                   \n[6] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/CD4+CD8a-\"                   \n[7] \"/singlet/live/lymphocytes/CD3+ T cells/non-NKT Cells/conv_Tcells/not_MAIT_Polygon/Double Negative CD3+ T cells\"\n\n\n\n\n\nRun gs_get_pop_paths(gs) by include a path = 1 argument. How is the output different compared to not providing path? What happens when you change this to path = 2?\nSuppose you do not know what is the parent population for Double Negative CD3+ T cells, what is an easy approach to get this information? Hint: Try help(gs_pop_get_paths) to check other available methods."
  },
  {
    "objectID": "vignettes/4_Gating_2.html#extracting-filtered-data",
    "href": "vignettes/4_Gating_2.html#extracting-filtered-data",
    "title": "Gating cells in cytoverse - Part 2",
    "section": "",
    "text": "Often, users may also want to extract the embedded expression data for a specified gated population for some downstream application. The cytoverse makes it super easy to extract this data. Moreover, the extracted data is preserved as a cytoframe or a cytoset for ease of use.\nThe 2 main methods are: 1. gs_pop_get_data 2. gh_pop_get_data\n\n# extract data\nextracted &lt;- gs_pop_get_data(gs,\n                y = \"live\",\n                inverse.transform = FALSE)\nextracted\n\nA cytoset with 4 samples.\n\n  column names:\n    FSC-A, FSC-H, SSC-A, B515-A, B610-A, B660-A, B710-A, B780-A, G575-A, G610-A, G660-A, G710-A, G780-A, R670-A, R730-A, R780-A, U390-A, U450-A, U500-A, U570-A, U660-A, U740-A, U785-A, V450-A, V510-A, V570-A, V605-A, V655-A, V710-A, V750-A, V785-A, remove_from_FS_FM, Time\n\ncytoset has been subsetted and can be realized through 'realize_view()'.\n\n\n\n\n\nTry running the above code as gh_pop_get_data. How are the results different?\nExtract the data from the gate Double Negative CD3+ T cells for the 1st sample and store it as sample_1. Transform the expression value for FSC-A. What happens to the data in gs?Hint\n\n\n# plot\nggcyto(gs,\n       subset = \"Double Negative CD3+ T cells\", \n       aes(x = \"FSC-A\", y = \"SSC-A\"))+\n  geom_hex(bins = 256)\nNotice that altering the extracted data leads to altered data within the GatingSet. This is because we did not create a new copy of the data using realize_view method. Importantly, this further highlights that the cytoframe, cytoset, and the GatingSet are all pointing to the same data!\n\n\nwhat does inverse.transform argument do?\nRun the following code:\n\n\nThis is only for example.\n\nanother_CD3_gate &lt;- matrix(c(-Inf,Inf), nrow = 2, ncol=1)\ncolnames(another_CD3_gate) &lt;- \"FSC-A\"\nanother_CD3_gate &lt;- rectangleGate(.gate = another_CD3_gate, filterId = \"CD3+ T cells\")\ngs_pop_add(gs, parent = \"non-NKT Cells\", gate = another_CD3_gate)\nrecompute(gs)\nplot(gs)\n\n\nNow try to extract the CD3+ T cells population using either gs_ or gh_ methods as above."
  },
  {
    "objectID": "vignettes/4_Gating_2.html#saving-extracted-data",
    "href": "vignettes/4_Gating_2.html#saving-extracted-data",
    "title": "Gating cells in cytoverse - Part 2",
    "section": "",
    "text": "Depending on the method called, the extracted data is either preserved as a cytoframe or a cytoset. As you experienced in the exercise, manipulating the extracted without performing a deep copy using realize_view leads to alteration of the data within the GatingSet object. As such, if extracting for further downstream application, it maybe worthwhile to save the data. For this, please refer to the Importing and Basics of working with FCS files for more details."
  },
  {
    "objectID": "vignettes/2_Spillover_transformation.html",
    "href": "vignettes/2_Spillover_transformation.html",
    "title": "Spillover, compensation, and Transformations",
    "section": "",
    "text": "In this section, we aim to clarify the concept of Spillover, and the use of spillover matrix to correct for this. The last part of this section will deal with various transformations of the underlying expression data to aid in visualization and interpretation.\n\n\nFlow cytometers (optics based: spectral or non-spectral) collect fluorescent signal from a cell as result of a laser excitation. Briefly, cell type C has been labelled with a marker M that is conjugated to a fluorophore (F). F is excited by a laser resulting in fluorescence. While the fluorescence has a emission maxima, the emission profile of F can span many nanometers. The cytometer has a dedicated detector (channel) A to detect peak emission of F. However, due to the spread of the emission of F, some signal from F is also “spilled” onto detector B, a detector for a different fluorophore.\nThe image below provides a concrete example.\n\n\n\nExcitation/Emission spectra for FITC. Taken from Bio-Rad. A is the dedicated detector for FITC. B is a secondary detector where FITC signal spills over.\n\n\nThe spillover of signal onto secondary detector(s) is additive and can be easily recovered (more on this below).\nRaw Signal in \\(B = \\text{Signal from FITC (spillover)} + \\text{Signal from another (perhaps dedicated) fluorophore}.\\)\nFITC signal detected erroneously by secondary detectors can be estimated by a process of fluorescence compensation which requires a set of controls be present to calculate the spillover. These controls are called Single Colour Controls and are acquired prior to sample acquisition. The purpose of the single colour control is to estimate the amount of spillover of emission from fluorophore F onto non-primary detectors (detector B in the image above).\nWe note, but will not discuss further here that there are a class of more advanced fluorescence-based cytometers known as spectral flow cytometers. Spectral instruments require a different and more specialized procedure to perform compensation.\n\n\n\nLet’s visualize the data to highlight the main issues related to spillover. We will make use of the ggcyto library from the cytoverse for this. We will dive into more details on the usage of ggcyto in a later section, as well as the “transformation” we are applying. For the moment, think of this transformation as a glorified log-transform to visualize the fluorescent signal that spans several orders of magnitude.\n\n\n\n\n\n\n\n\nIn example 1, the 2 fluorophores: PE-Cy5 and PE-Cy5.5 are spilling onto each other, making it impossible to resolve CD3+ (T cells) from non-T cells. However, after correcting for spillover (2nd plot), we see that two populations are visible in the G660-A CD3 PE-Cy5 channel.\nIn example 2, we see a population of events that are positive of marker: Live Dead UV Blue. It would be tempting to exclude these events as this marker is used to identify dead cells. However, in correctly compensated data, we see that this population actually is not present, but rather was an artifact of another dye spilling onto the U450 channel!\n\n\n\n\n\nIn many cases, the spillover matrix (which is used to correct the spillover) is attached to the .fcs files within $SPILLOVER,SPILL,or SPILL keywords. In cytoverse, we can check for the presence of by using the function spillover(cf).\n\n\nFor this example, we are using data from the following dataset FR-FCM-ZZ36. The data was published in this manuscript.\n\n# absent spill\ncf_absent &lt;- load_cytoframe_from_fcs(\"data/FlowRepository_FR-FCM-ZZ36_files/pbmc_luca.fcs\")\n\n# check spillover results\nspillover(cf_absent)\n\n$SPILL\n      Alexa Fluor 488-A PerCP-Cy5-5-A APC-A APC-Cy7-A Alexa Fluor 405-A\n [1,]                 1             0     0         0                 0\n [2,]                 0             1     0         0                 0\n [3,]                 0             0     1         0                 0\n [4,]                 0             0     0         1                 0\n [5,]                 0             0     0         0                 1\n [6,]                 0             0     0         0                 0\n [7,]                 0             0     0         0                 0\n [8,]                 0             0     0         0                 0\n [9,]                 0             0     0         0                 0\n[10,]                 0             0     0         0                 0\n[11,]                 0             0     0         0                 0\n[12,]                 0             0     0         0                 0\n[13,]                 0             0     0         0                 0\n[14,]                 0             0     0         0                 0\n      Alexa Fluor 430-A Qdot 605-A Qdot 655-A Qdot 800-A PE-A PE-Texas Red-A\n [1,]                 0          0          0          0    0              0\n [2,]                 0          0          0          0    0              0\n [3,]                 0          0          0          0    0              0\n [4,]                 0          0          0          0    0              0\n [5,]                 0          0          0          0    0              0\n [6,]                 1          0          0          0    0              0\n [7,]                 0          1          0          0    0              0\n [8,]                 0          0          1          0    0              0\n [9,]                 0          0          0          1    0              0\n[10,]                 0          0          0          0    1              0\n[11,]                 0          0          0          0    0              1\n[12,]                 0          0          0          0    0              0\n[13,]                 0          0          0          0    0              0\n[14,]                 0          0          0          0    0              0\n      PE-Cy5-A PE-Cy5-5-A PE-Cy7-A\n [1,]        0          0        0\n [2,]        0          0        0\n [3,]        0          0        0\n [4,]        0          0        0\n [5,]        0          0        0\n [6,]        0          0        0\n [7,]        0          0        0\n [8,]        0          0        0\n [9,]        0          0        0\n[10,]        0          0        0\n[11,]        0          0        0\n[12,]        1          0        0\n[13,]        0          1        0\n[14,]        0          0        1\n\n$spillover\nNULL\n\n$`$SPILLOVER`\nNULL\n\n\nNotice that there are 3 slots. Importantly, we notice a matrix within $SPILL slot which has 1’s in the diagonal and 0’s elsewhere. This is an identity matrix.\nObserving an identity matrix is likely an indication that the spillover has not been calculated. If this is the case, please see the section: Calculating spillover from single colour controls (optional).\n\n\n\nFor this example, we are using the dataset from FR-FCM-Z5PC. The dataset was published in the following paper.\n\n# load cytoframe\ncf &lt;- load_cytoframe_from_fcs(\"data/fcs-data/4000_BDC-CR1.fcs\")\n\n# show spillover\nspillover(cf)\n\n$SPILL\nNULL\n\n$spillover\nNULL\n\n$`$SPILLOVER`\n             B515-A        B610-A        B660-A        B710-A        B780-A\n [1,]  1.0000000000  0.0654894460  0.0356302035  0.0029254752  0.0008449831\n [2,]  0.0093862808  1.0000000000  0.7882951056  0.0745542215  0.0250840047\n [3,]  0.0054477562  0.0308300643  1.0000000000  0.1125626913  0.0374552874\n [4,]  0.0232877053  0.1173532702  0.8955441539  1.0000000000  0.4274273094\n [5,]  0.0263317480  0.0866490000  0.1599768604  0.0324309609  1.0000000000\n [6,]  0.0029226586  0.3956117744  0.2698294289  0.0235842703  0.0060479979\n [7,]  0.0023861688  0.9153572517  0.7085405010  0.0775836676  0.0241986406\n [8,]  0.0014122317  0.0155860369  1.6380846002  0.2707078172  0.0949168290\n [9,]  0.0012543619  0.0146942070  0.1237795271  0.3159420000  0.1320410000\n[10,]  0.0030060073  0.0142997906  0.0119625555  0.0053839156  1.0067100000\n[11,] -0.0002186754  0.0003868355  0.0793509345  0.0076994793  0.0027485207\n[12,]  0.0006298100  0.0001181542  0.0072717422  0.0232312763  0.0083635498\n[13,]  0.0006324496  0.0002277156  0.0023505209  0.0004356428  0.0450062282\n[14,]  0.0000371600 -0.0000037269  0.0000402270  0.0000067503 -0.0000205130\n[15,]  0.0152840902  0.0007469344 -0.0000655014  0.0002516557 -0.0000242346\n[16,]  0.0698186812  0.0050055112  0.0032244478  0.0002924284  0.0000892089\n[17,]  0.0018094627  0.1801790047  0.1086006366  0.0092703868  0.0025147988\n[18,]  0.0007380500  0.0021129984  0.0928220000  0.0178822285  0.0053203495\n[19,]  0.0001832170  0.0001874975  0.0017087346  0.0910590886  0.1396358857\n[20,]  0.0001161554  0.0015137962  0.0013928872  0.0002876104  0.0207331506\n[21,]  0.0000259284  0.0000026205  0.0000046004 -0.0000024305 -0.0000094620\n[22,]  0.0024755568  0.0007875071  0.0009465724  0.0001304997 -0.0000651446\n[23,] -0.0000664517  0.0979500000  0.0837278085  0.0082513490  0.0025234889\n[24,]  0.0002543497  0.2477079125  0.2676769930  0.0295185107  0.0107736937\n[25,]  0.0000000000  0.0047715344  0.0760284035  0.0092458021  0.0027141047\n[26,]  0.0001085469  0.0000958875  0.0071224283  0.0700000000  0.0516751244\n[27,]  0.0001024194  0.0003073189  0.0003971912  0.0084841674  0.0821751638\n[28,]  0.0001011734  0.0002092628  0.0003642644  0.0002839300  0.0300000000\n            G575-A       G610-A        G660-A       G710-A        G780-A\n [1,] 0.0082839158 0.0028790182  0.0008539079 0.0003357982  0.0000336139\n [2,] 0.0252292729 0.4906020000  0.1845662022 0.0728974850  0.0076792734\n [3,] 0.0023043205 0.0037468212  0.1752600000 0.0797172871  0.0091302494\n [4,] 0.0105695634 0.0118602859  0.1227136768 0.7772650000  0.1191710000\n [5,] 0.0257745563 0.0265636944  0.0229724955 0.0240359137  0.2646130000\n [6,] 1.0000000000 0.3515799708  0.1353662458 0.0533091593  0.0051051806\n [7,] 0.1808211022 1.0000000000  0.4300340000 0.2069533275  0.0227258875\n [8,] 0.0731262317 0.0285733034  1.0000000000 0.8105253391  0.1024470712\n [9,] 0.0682671508 0.0254464529  0.0855404863 1.0000000000  0.1499063932\n[10,] 0.0857184693 0.0348000639  0.0147374155 0.0269637133  1.0000000000\n[11,] 0.0001027807 0.0045671664  0.4195790000 0.1924994215  0.0267805730\n[12,] 0.0000728624 0.0004081205  0.0205041810 0.2815082716  0.0375776427\n[13,] 0.0004644973 0.0007327559  0.0122034141 0.0096435857  0.2780472618\n[14,] 0.0000370925 0.0000342040  0.0000472205 0.0000453873  0.0000091818\n[15,] 0.0087818949 0.0031007530  0.0011377035 0.0008283278  0.0002096875\n[16,] 0.0002804399 0.0001885965  0.0000745089 0.0001090675  0.0000188601\n[17,] 1.8494699136 0.7346175460  0.2466528393 0.0922051963  0.0092241886\n[18,] 0.0010152936 0.0135096316  0.4976860000 0.2729318069  0.0296728547\n[19,] 0.0003248848 0.0003437068  0.0005400292 0.0399725963  0.0208155392\n[20,] 0.0019391802 0.0028833039  0.0014587076 0.0013805414  0.0254227914\n[21,] 0.0000070914 0.0000032455 -0.0000066467 0.0000052504  0.0000021341\n[22,] 0.0001826569 0.0000825645  0.0000092462 0.0001495319 -0.0000116460\n[23,] 0.5641670000 0.2911900000  0.1344737692 0.0589841904  0.0066485143\n[24,] 0.1838817631 1.1084860000  0.7282579556 0.3572482021  0.0469262690\n[25,] 0.0026408394 0.0292224009  0.2607304382 0.1420003758  0.0158387599\n[26,] 0.0001328083 0.0001273373  0.0020128687 0.0848199753  0.0160702874\n[27,] 0.0002398960 0.0002263868  0.0001773840 0.0092101315  0.0254895948\n[28,] 0.0002269509 0.0002754166  0.0003101643 0.0017780329  0.0463526169\n             R670-A        R730-A       R780-A        U390-A        U450-A\n [1,] -0.0000063305  0.0000084621 0.0000000000  0.0000446083  0.0000159830\n [2,]  0.0081509961  0.0046717692 0.0004831082  0.0000000000 -0.0000039389\n [3,]  0.2613130000  0.1647444481 0.0165117267  0.0000000000  0.0000140163\n [4,]  0.1643668782  0.7351185260 0.1132544960  0.0000304994  0.0000109278\n [5,]  0.0007803282  0.0164450922 0.0651700000  0.0000000000 -0.0000622848\n [6,]  0.0001831487  0.0002075091 0.0000077461  0.0000000000  0.0000298887\n [7,]  0.0045593367  0.0032172664 0.0003826008  0.0000159905 -0.0000113539\n [8,]  0.1828690000  0.1497340000 0.0155379084  0.0000000000  0.0000065421\n [9,]  0.0166056334  0.1397122725 0.0211950581  0.0000296768  0.0000053089\n[10,]  0.0003457433  0.0131970792 0.0613852390  0.0000220811 -0.0000195688\n[11,]  1.0000000000  0.6746970000 0.0672186896  0.0000717944 -0.0000255661\n[12,]  0.0677030567  1.0000000000 0.1024304806  0.0000177877 -0.0000031719\n[13,]  0.0395138625  0.1729764753 1.0000000000  0.0008962927  0.0000219476\n[14,]  0.0000260464  0.0000183553 0.0000000000  1.0000000000  0.0715668942\n[15,]  0.0000903667  0.0004302125 0.0000355452  1.6375342268  1.0000000000\n[16,]  0.0000000000  0.0000227529 0.0000000000  0.0680929018  0.0601659197\n[17,]  0.0000548722  0.0000588240 0.0000000000  0.1123320000  0.0084416026\n[18,]  0.9535728348  0.7421256270 0.0748409002  0.0662397445  0.0116252447\n[19,]  0.0026718912  0.7261888317 0.1267611796  0.0676552190  0.0113170554\n[20,]  0.0005431531  0.0096017096 0.1544340070  0.2960000000  0.0493877222\n[21,]  0.0000072480 -0.0000032586 0.0000000000  0.0002074509  0.0199387823\n[22,]  0.0000996095  0.0000000000 0.0000000000 -0.0001386642  0.0275791593\n[23,]  0.0002409273  0.0001752918 0.0000000000 -0.0001945789  0.0018937711\n[24,]  0.0139532270  0.0108588675 0.0012493952  0.0000827472  0.0019518068\n[25,]  0.4010171690  0.3095665279 0.0327516235 -0.0001235885  0.0020041568\n[26,]  0.0204302418  0.9997730000 0.1222550376 -0.0001052901  0.0016909975\n[27,]  0.0001340774  0.1392279331 0.0682937436 -0.0000683812  0.0006855189\n[28,]  0.0005405149  0.0151929227 0.0494363782 -0.0000328085  0.0009994182\n             U500-A        U570-A       U660-A       U740-A       U785-A\n [1,]  0.0235917813  0.0061384441 0.0004102750 0.0000773913 0.0000000000\n [2,]  0.0003203807  0.0052602974 0.0249692722 0.0058028052 0.0017509891\n [3,]  0.0001879891  0.0010441665 0.0318492556 0.0104707662 0.0030321952\n [4,]  0.0008401743  0.0043630052 0.0266911262 0.0706590000 0.0403032888\n [5,]  0.0008370850  0.0057473994 0.0038369048 0.0204155733 0.1335024236\n [6,]  0.0001610826  0.0829439007 0.0112098217 0.0017331871 0.0005784301\n [7,] -0.0000224251  0.0059834211 0.0176930000 0.0057936405 0.0019580358\n [8,]  0.0000322542  0.0010624577 0.0338630000 0.0202256964 0.0052461463\n [9,]  0.0000209065  0.0011503056 0.0027375114 0.0163066622 0.0085663395\n[10,] -0.0000309667  0.0007702062 0.0001189082 0.0096545484 0.0757493500\n[11,] -0.0001006848 -0.0000506688 0.0490000000 0.0254567771 0.0055693489\n[12,]  0.0000250980 -0.0000062958 0.0026131953 0.0249920000 0.0086412505\n[13,]  0.0005225758  0.0000000000 0.0011782568 0.0113432961 0.1187953605\n[14,]  0.0958982944  0.0067529414 0.0004387057 0.0001325069 0.0000251467\n[15,]  1.5135519893  0.1383666752 0.0169096199 0.0067897017 0.0032852189\n[16,]  1.0000000000  0.1664025713 0.0138239208 0.0029111888 0.0009098811\n[17,]  0.0131786211  1.0000000000 0.0957280252 0.0171014040 0.0055378535\n[18,]  0.0193760773  0.0026755322 1.0000000000 0.3582442013 0.1021335267\n[19,]  0.0181141497  0.0018046653 0.0021976061 1.0000000000 0.3123709707\n[20,]  0.0768280802  0.0083181330 0.0014921176 0.0211529136 1.0000000000\n[21,]  0.0330780901  0.0026794268 0.0001224306 0.0000282899 0.0000000000\n[22,]  0.4062437424  0.1580000000 0.0317046513 0.0096792138 0.0034038893\n[23,]  0.0034116521  0.1358300000 0.0334930036 0.0076754942 0.0025117156\n[24,]  0.0034847779  0.0773736550 0.2421230000 0.0818191394 0.0276059349\n[25,]  0.0034069479  0.0010978286 0.3356809153 0.0968081821 0.0300679041\n[26,]  0.0031418821  0.0004126759 0.0066743089 0.2965810109 0.1233777513\n[27,]  0.0013164596  0.0004805398 0.0001831665 0.2295597332 0.1583617556\n[28,]  0.0020677066  0.0003846433 0.0003070539 0.0304262084 0.1703870000\n             V450-A        V510-A       V570-A        V605-A       V655-A\n [1,]  0.0001126169  0.0244469354 0.0133239975  0.0017077163 0.0006419635\n [2,] -0.0000554311  0.0013903555 0.0237150000  0.1137803713 0.0791702484\n [3,] -0.0000325252  0.0008273251 0.0082851408  0.0039091379 0.1212970000\n [4,] -0.0000383267  0.0034433249 0.0352893754  0.0149409056 0.0874069877\n [5,] -0.0001771661  0.0029766981 0.0337066863  0.0126301738 0.0130122234\n [6,] -0.0000615977 -0.0000685174 0.2265353728  0.0432247652 0.0166494501\n [7,] -0.0000401281 -0.0000110945 0.0108360339  0.0412987185 0.0296288722\n [8,] -0.0000228412 -0.0000063151 0.0026596753  0.0005125683 0.0551460000\n [9,]  0.0000000000  0.0000206532 0.0029179225  0.0005357699 0.0035614167\n[10,] -0.0001104826 -0.0000305945 0.0019596098  0.0003289707 0.0001785058\n[11,]  0.0000000000  0.0000499562 0.0000000000  0.0002176366 0.0617797375\n[12,]  0.0000449063  0.0000748374 0.0000000000  0.0000143900 0.0026653617\n[13,]  0.0016213806  0.0002739234 0.0000522934 -0.0000418152 0.0014001869\n[14,]  0.0028495698  0.0005212159 0.0001460806  0.0000029026 0.0000084195\n[15,]  0.5534992576  0.0641345305 0.0074114867  0.0008045019 0.0005984415\n[16,]  0.0162614522  0.1950370000 0.0514698507  0.0069806590 0.0024811015\n[17,]  0.0006973093  0.0002682714 0.0664240134  0.0103207046 0.0038262242\n[18,]  0.0010439705  0.0003932483 0.0003280923  0.0008245414 0.0906160000\n[19,]  0.0009210165  0.0002829874 0.0001068950  0.0000071344 0.0001537055\n[20,]  0.0041824407  0.0011299998 0.0004103352  0.0000548546 0.0000664001\n[21,]  1.0000000000  0.0994629766 0.0149634907  0.0015441998 0.0004792632\n[22,]  0.1943348870  1.0000000000 0.7638979136  0.1500932160 0.0797061038\n[23,]  0.2081230000  0.0211239114 1.0000000000  0.2341494800 0.1224183543\n[24,]  0.2156768802  0.0220420896 0.2084451885  1.0000000000 0.7719972989\n[25,]  0.1939906460  0.0208337609 0.0068534717  0.0470037792 1.0000000000\n[26,]  0.1845147305  0.0203733765 0.0048240293  0.0007441674 0.0196061776\n[27,]  0.0933951231  0.0100299903 0.0042920248  0.0009033967 0.0009307708\n[28,]  0.1016800000  0.0125135507 0.0036818403  0.0007662927 0.0013439907\n            V710-A       V750-A       V785-A\n [1,] 0.0002971922 0.0001257152 0.0000583097\n [2,] 0.0366353688 0.0160234558 0.0100516039\n [3,] 0.0720700000 0.0269798099 0.0154732634\n [4,] 0.5207322077 0.2159840000 0.1798193819\n [5,] 0.0128252630 0.1001290000 0.5813326554\n [6,] 0.0071923334 0.0023822001 0.0013819583\n [7,] 0.0162058919 0.0063538387 0.0038768631\n [8,] 0.0409619444 0.0224142160 0.0110338571\n [9,] 0.0467728361 0.0188471465 0.0165369398\n[10,] 0.0005046499 0.0316497285 0.1558437227\n[11,] 0.0289495267 0.0206439009 0.0095696913\n[12,] 0.0360590000 0.0401390000 0.0263410000\n[13,] 0.0009976876 0.0329562787 0.2253836760\n[14,] 0.0000217317 0.0000170133 0.0000019936\n[15,] 0.0004410047 0.0004482531 0.0003501377\n[16,] 0.0010815226 0.0004720806 0.0002951247\n[17,] 0.0016619655 0.0005979447 0.0003571689\n[18,] 0.0515933368 0.0234699167 0.0132197184\n[19,] 0.0232060595 0.0690649491 0.0393457654\n[20,] 0.0000580466 0.0027328942 0.1055924723\n[21,] 0.0002364643 0.0001253462 0.0001236473\n[22,] 0.0461123165 0.0222024133 0.0157047765\n[23,] 0.0597285658 0.0249064740 0.0157728879\n[24,] 0.4081358956 0.2031510119 0.1297043514\n[25,] 0.5812987029 0.2329972275 0.1391381582\n[26,] 1.0000000000 0.6294465489 0.5085686408\n[27,] 0.0899398069 1.0000000000 0.8329581697\n[28,] 0.0063802415 0.2152920000 1.0000000000\n\n\nWe notice a few important details.\n\nIt is not necessary that all 3 keywords have a matrix. Nor is it necessary that the matrix be present in a specific keyword.\nThe spillover matrix is square. This is because the user will run 1 single colour control for each channel/marker they intend to acquire. In this example its 28 x 28\nThe spillover matrix is non-identity with 1’s in the diagonal!\n\nThe columns of the spillover matrix are the detectors while the rows are contribution from each fluorophore. Visualizing it as a heatmap is sometimes more helpful\n\n\n\n\n\nLooking at the figure, column 2: B610-A (detector for fluorophore BB630) has high spillover from flurophore: PE-Dazzle594 and PE.\nIn fact, when we look at the emission spectrum of the 2 dyes (PE and BB630) we see that this issue is apparent:\nThe image was created at https://www.bdbiosciences.com/en-ca/resources/bd-spectrum-viewer using the BD spectrum viewer tool.\n\n\n\n\nNow that we have a valid spillover matrix, how do we use it to correct the data?\nFirst, we would like to highlight: SPILLOVER CORRECTION IS DONE ON THE RAW (UNTRANSFORMED) DATA.\nNow to perform spillover correction (Compensation). In the cytoverse this is done by a simple call to compensate.\n\n# single call to compensate \n# spillover(cf)[[3]] indicates where the matrix to use lives\ncf_comp &lt;- compensate(\n  x = realize_view(cf),\n  spillover = spillover(cf)[[3]]\n) \n\n\n\n\n\nCytometry data tends to have a very high dynamic range. For example: the range of values in PE-Cy5-5-A channel in the FCS we have been working with is -111 2621543. The difference between cells that do not express a marker of interest and a cell that expresses variable level of marker could be order of magnitude. In such a scenario, transformation of the data can aid in better visualization and representation of the biological phenomena.\nThere are multiple approaches to transform the data in cytoverse. We will identify a few common ones as well as demonstrate how to create new transformations.\nFirst, let’s visualize why transformation is necessary. We go back to working with data from FR-FCM-Z5PC.\n\n\n\n\n\nAs we see, the variety of transformations aids in visualization and interpretation of the data.\nAlso note that the choice of transformation can and will affect the interpretation. As such, use a healthy dose of caution and follow established best practices. As well, when in doubt, talk to your collaborators.\n\n\nThe cytoverse libraries: flowWorkspace and flowCore have a multiple commonly used transformations (some are shown above) as well, one can also create a custom transformation if required.\nLet’s first use a built in transformation.\n\n# transforming using cytoverse functions\n# define a transformation\nasinh_trans &lt;- flowWorkspace::asinh_Gml2()\n\n# create a transformList that indicates which parameters to transform\nmy_trans_list &lt;- flowCore::transformList(\n  from = names(\n    markernames(cf)\n  ),\n  tfun = asinh_trans\n)\n\n# transform \ncf_transformed &lt;- flowCore::transform(\n  realize_view(cf),\n  my_trans_list\n)\n\n\n\n\n\n\nAnother option is to use a user defined transformation.\n\n# define a transformation\nmy_trans &lt;- function(x){\n  return(sqrt(abs(x)))\n}\n\n# create a transformList\nmy_trans_list &lt;- flowCore::transformList(\n  from = names(\n    markernames(cf)\n  ), \n  tfun = my_trans\n)\n\n# transform\ncf_transformed &lt;- transform(\n  realize_view(cf),\n  my_trans_list\n)\n\nWe can also transform a set of FCS files (cytoset)\n\n# read in a cytoset\ncs &lt;- load_cytoset_from_fcs(path = \"data/fcs-data/\")\n\n# extract per file compensation matrix into a list\ncompensation_list &lt;- lapply(cytoset_to_list(cs),\n                            function(x)spillover(x)[[3]])\n\n# compensate\ncs &lt;- compensate(cs, compensation_list)\n\n# using asinh_trans defined previously\nmy_trans_list &lt;- flowCore::transformList(\n  from = names(\n    markernames(cf)\n  ),\n  tfun = asinh_trans\n)\n\n# transform: this will transform the underlying data \ncs &lt;- transform(cs,my_trans_list)\n\n\n\n\n\nHow can you tell if the data have been compensated? Use your preferred plotting method to generate a scatter plot for the following markers: CADM1 and CD141 from cf and cf_comp. You may need to transform the data for appropriate visualization.\nSuppose the .fcs file does not have a spillover matrix or has an identity matrix. How confident can you be the data have been previously compensated (or not) ?"
  },
  {
    "objectID": "vignettes/2_Spillover_transformation.html#spillover",
    "href": "vignettes/2_Spillover_transformation.html#spillover",
    "title": "Spillover, compensation, and Transformations",
    "section": "",
    "text": "Flow cytometers (optics based: spectral or non-spectral) collect fluorescent signal from a cell as result of a laser excitation. Briefly, cell type C has been labelled with a marker M that is conjugated to a fluorophore (F). F is excited by a laser resulting in fluorescence. While the fluorescence has a emission maxima, the emission profile of F can span many nanometers. The cytometer has a dedicated detector (channel) A to detect peak emission of F. However, due to the spread of the emission of F, some signal from F is also “spilled” onto detector B, a detector for a different fluorophore.\nThe image below provides a concrete example.\n\n\n\nExcitation/Emission spectra for FITC. Taken from Bio-Rad. A is the dedicated detector for FITC. B is a secondary detector where FITC signal spills over.\n\n\nThe spillover of signal onto secondary detector(s) is additive and can be easily recovered (more on this below).\nRaw Signal in \\(B = \\text{Signal from FITC (spillover)} + \\text{Signal from another (perhaps dedicated) fluorophore}.\\)\nFITC signal detected erroneously by secondary detectors can be estimated by a process of fluorescence compensation which requires a set of controls be present to calculate the spillover. These controls are called Single Colour Controls and are acquired prior to sample acquisition. The purpose of the single colour control is to estimate the amount of spillover of emission from fluorophore F onto non-primary detectors (detector B in the image above).\nWe note, but will not discuss further here that there are a class of more advanced fluorescence-based cytometers known as spectral flow cytometers. Spectral instruments require a different and more specialized procedure to perform compensation."
  },
  {
    "objectID": "vignettes/2_Spillover_transformation.html#importance-of-spillover-correction",
    "href": "vignettes/2_Spillover_transformation.html#importance-of-spillover-correction",
    "title": "Spillover, compensation, and Transformations",
    "section": "",
    "text": "Let’s visualize the data to highlight the main issues related to spillover. We will make use of the ggcyto library from the cytoverse for this. We will dive into more details on the usage of ggcyto in a later section, as well as the “transformation” we are applying. For the moment, think of this transformation as a glorified log-transform to visualize the fluorescent signal that spans several orders of magnitude.\n\n\n\n\n\n\n\n\nIn example 1, the 2 fluorophores: PE-Cy5 and PE-Cy5.5 are spilling onto each other, making it impossible to resolve CD3+ (T cells) from non-T cells. However, after correcting for spillover (2nd plot), we see that two populations are visible in the G660-A CD3 PE-Cy5 channel.\nIn example 2, we see a population of events that are positive of marker: Live Dead UV Blue. It would be tempting to exclude these events as this marker is used to identify dead cells. However, in correctly compensated data, we see that this population actually is not present, but rather was an artifact of another dye spilling onto the U450 channel!"
  },
  {
    "objectID": "vignettes/2_Spillover_transformation.html#spillover-matrix-what-does-it-look-like-where-do-you-find-it-how-can-you-use-it",
    "href": "vignettes/2_Spillover_transformation.html#spillover-matrix-what-does-it-look-like-where-do-you-find-it-how-can-you-use-it",
    "title": "Spillover, compensation, and Transformations",
    "section": "",
    "text": "In many cases, the spillover matrix (which is used to correct the spillover) is attached to the .fcs files within $SPILLOVER,SPILL,or SPILL keywords. In cytoverse, we can check for the presence of by using the function spillover(cf).\n\n\nFor this example, we are using data from the following dataset FR-FCM-ZZ36. The data was published in this manuscript.\n\n# absent spill\ncf_absent &lt;- load_cytoframe_from_fcs(\"data/FlowRepository_FR-FCM-ZZ36_files/pbmc_luca.fcs\")\n\n# check spillover results\nspillover(cf_absent)\n\n$SPILL\n      Alexa Fluor 488-A PerCP-Cy5-5-A APC-A APC-Cy7-A Alexa Fluor 405-A\n [1,]                 1             0     0         0                 0\n [2,]                 0             1     0         0                 0\n [3,]                 0             0     1         0                 0\n [4,]                 0             0     0         1                 0\n [5,]                 0             0     0         0                 1\n [6,]                 0             0     0         0                 0\n [7,]                 0             0     0         0                 0\n [8,]                 0             0     0         0                 0\n [9,]                 0             0     0         0                 0\n[10,]                 0             0     0         0                 0\n[11,]                 0             0     0         0                 0\n[12,]                 0             0     0         0                 0\n[13,]                 0             0     0         0                 0\n[14,]                 0             0     0         0                 0\n      Alexa Fluor 430-A Qdot 605-A Qdot 655-A Qdot 800-A PE-A PE-Texas Red-A\n [1,]                 0          0          0          0    0              0\n [2,]                 0          0          0          0    0              0\n [3,]                 0          0          0          0    0              0\n [4,]                 0          0          0          0    0              0\n [5,]                 0          0          0          0    0              0\n [6,]                 1          0          0          0    0              0\n [7,]                 0          1          0          0    0              0\n [8,]                 0          0          1          0    0              0\n [9,]                 0          0          0          1    0              0\n[10,]                 0          0          0          0    1              0\n[11,]                 0          0          0          0    0              1\n[12,]                 0          0          0          0    0              0\n[13,]                 0          0          0          0    0              0\n[14,]                 0          0          0          0    0              0\n      PE-Cy5-A PE-Cy5-5-A PE-Cy7-A\n [1,]        0          0        0\n [2,]        0          0        0\n [3,]        0          0        0\n [4,]        0          0        0\n [5,]        0          0        0\n [6,]        0          0        0\n [7,]        0          0        0\n [8,]        0          0        0\n [9,]        0          0        0\n[10,]        0          0        0\n[11,]        0          0        0\n[12,]        1          0        0\n[13,]        0          1        0\n[14,]        0          0        1\n\n$spillover\nNULL\n\n$`$SPILLOVER`\nNULL\n\n\nNotice that there are 3 slots. Importantly, we notice a matrix within $SPILL slot which has 1’s in the diagonal and 0’s elsewhere. This is an identity matrix.\nObserving an identity matrix is likely an indication that the spillover has not been calculated. If this is the case, please see the section: Calculating spillover from single colour controls (optional).\n\n\n\nFor this example, we are using the dataset from FR-FCM-Z5PC. The dataset was published in the following paper.\n\n# load cytoframe\ncf &lt;- load_cytoframe_from_fcs(\"data/fcs-data/4000_BDC-CR1.fcs\")\n\n# show spillover\nspillover(cf)\n\n$SPILL\nNULL\n\n$spillover\nNULL\n\n$`$SPILLOVER`\n             B515-A        B610-A        B660-A        B710-A        B780-A\n [1,]  1.0000000000  0.0654894460  0.0356302035  0.0029254752  0.0008449831\n [2,]  0.0093862808  1.0000000000  0.7882951056  0.0745542215  0.0250840047\n [3,]  0.0054477562  0.0308300643  1.0000000000  0.1125626913  0.0374552874\n [4,]  0.0232877053  0.1173532702  0.8955441539  1.0000000000  0.4274273094\n [5,]  0.0263317480  0.0866490000  0.1599768604  0.0324309609  1.0000000000\n [6,]  0.0029226586  0.3956117744  0.2698294289  0.0235842703  0.0060479979\n [7,]  0.0023861688  0.9153572517  0.7085405010  0.0775836676  0.0241986406\n [8,]  0.0014122317  0.0155860369  1.6380846002  0.2707078172  0.0949168290\n [9,]  0.0012543619  0.0146942070  0.1237795271  0.3159420000  0.1320410000\n[10,]  0.0030060073  0.0142997906  0.0119625555  0.0053839156  1.0067100000\n[11,] -0.0002186754  0.0003868355  0.0793509345  0.0076994793  0.0027485207\n[12,]  0.0006298100  0.0001181542  0.0072717422  0.0232312763  0.0083635498\n[13,]  0.0006324496  0.0002277156  0.0023505209  0.0004356428  0.0450062282\n[14,]  0.0000371600 -0.0000037269  0.0000402270  0.0000067503 -0.0000205130\n[15,]  0.0152840902  0.0007469344 -0.0000655014  0.0002516557 -0.0000242346\n[16,]  0.0698186812  0.0050055112  0.0032244478  0.0002924284  0.0000892089\n[17,]  0.0018094627  0.1801790047  0.1086006366  0.0092703868  0.0025147988\n[18,]  0.0007380500  0.0021129984  0.0928220000  0.0178822285  0.0053203495\n[19,]  0.0001832170  0.0001874975  0.0017087346  0.0910590886  0.1396358857\n[20,]  0.0001161554  0.0015137962  0.0013928872  0.0002876104  0.0207331506\n[21,]  0.0000259284  0.0000026205  0.0000046004 -0.0000024305 -0.0000094620\n[22,]  0.0024755568  0.0007875071  0.0009465724  0.0001304997 -0.0000651446\n[23,] -0.0000664517  0.0979500000  0.0837278085  0.0082513490  0.0025234889\n[24,]  0.0002543497  0.2477079125  0.2676769930  0.0295185107  0.0107736937\n[25,]  0.0000000000  0.0047715344  0.0760284035  0.0092458021  0.0027141047\n[26,]  0.0001085469  0.0000958875  0.0071224283  0.0700000000  0.0516751244\n[27,]  0.0001024194  0.0003073189  0.0003971912  0.0084841674  0.0821751638\n[28,]  0.0001011734  0.0002092628  0.0003642644  0.0002839300  0.0300000000\n            G575-A       G610-A        G660-A       G710-A        G780-A\n [1,] 0.0082839158 0.0028790182  0.0008539079 0.0003357982  0.0000336139\n [2,] 0.0252292729 0.4906020000  0.1845662022 0.0728974850  0.0076792734\n [3,] 0.0023043205 0.0037468212  0.1752600000 0.0797172871  0.0091302494\n [4,] 0.0105695634 0.0118602859  0.1227136768 0.7772650000  0.1191710000\n [5,] 0.0257745563 0.0265636944  0.0229724955 0.0240359137  0.2646130000\n [6,] 1.0000000000 0.3515799708  0.1353662458 0.0533091593  0.0051051806\n [7,] 0.1808211022 1.0000000000  0.4300340000 0.2069533275  0.0227258875\n [8,] 0.0731262317 0.0285733034  1.0000000000 0.8105253391  0.1024470712\n [9,] 0.0682671508 0.0254464529  0.0855404863 1.0000000000  0.1499063932\n[10,] 0.0857184693 0.0348000639  0.0147374155 0.0269637133  1.0000000000\n[11,] 0.0001027807 0.0045671664  0.4195790000 0.1924994215  0.0267805730\n[12,] 0.0000728624 0.0004081205  0.0205041810 0.2815082716  0.0375776427\n[13,] 0.0004644973 0.0007327559  0.0122034141 0.0096435857  0.2780472618\n[14,] 0.0000370925 0.0000342040  0.0000472205 0.0000453873  0.0000091818\n[15,] 0.0087818949 0.0031007530  0.0011377035 0.0008283278  0.0002096875\n[16,] 0.0002804399 0.0001885965  0.0000745089 0.0001090675  0.0000188601\n[17,] 1.8494699136 0.7346175460  0.2466528393 0.0922051963  0.0092241886\n[18,] 0.0010152936 0.0135096316  0.4976860000 0.2729318069  0.0296728547\n[19,] 0.0003248848 0.0003437068  0.0005400292 0.0399725963  0.0208155392\n[20,] 0.0019391802 0.0028833039  0.0014587076 0.0013805414  0.0254227914\n[21,] 0.0000070914 0.0000032455 -0.0000066467 0.0000052504  0.0000021341\n[22,] 0.0001826569 0.0000825645  0.0000092462 0.0001495319 -0.0000116460\n[23,] 0.5641670000 0.2911900000  0.1344737692 0.0589841904  0.0066485143\n[24,] 0.1838817631 1.1084860000  0.7282579556 0.3572482021  0.0469262690\n[25,] 0.0026408394 0.0292224009  0.2607304382 0.1420003758  0.0158387599\n[26,] 0.0001328083 0.0001273373  0.0020128687 0.0848199753  0.0160702874\n[27,] 0.0002398960 0.0002263868  0.0001773840 0.0092101315  0.0254895948\n[28,] 0.0002269509 0.0002754166  0.0003101643 0.0017780329  0.0463526169\n             R670-A        R730-A       R780-A        U390-A        U450-A\n [1,] -0.0000063305  0.0000084621 0.0000000000  0.0000446083  0.0000159830\n [2,]  0.0081509961  0.0046717692 0.0004831082  0.0000000000 -0.0000039389\n [3,]  0.2613130000  0.1647444481 0.0165117267  0.0000000000  0.0000140163\n [4,]  0.1643668782  0.7351185260 0.1132544960  0.0000304994  0.0000109278\n [5,]  0.0007803282  0.0164450922 0.0651700000  0.0000000000 -0.0000622848\n [6,]  0.0001831487  0.0002075091 0.0000077461  0.0000000000  0.0000298887\n [7,]  0.0045593367  0.0032172664 0.0003826008  0.0000159905 -0.0000113539\n [8,]  0.1828690000  0.1497340000 0.0155379084  0.0000000000  0.0000065421\n [9,]  0.0166056334  0.1397122725 0.0211950581  0.0000296768  0.0000053089\n[10,]  0.0003457433  0.0131970792 0.0613852390  0.0000220811 -0.0000195688\n[11,]  1.0000000000  0.6746970000 0.0672186896  0.0000717944 -0.0000255661\n[12,]  0.0677030567  1.0000000000 0.1024304806  0.0000177877 -0.0000031719\n[13,]  0.0395138625  0.1729764753 1.0000000000  0.0008962927  0.0000219476\n[14,]  0.0000260464  0.0000183553 0.0000000000  1.0000000000  0.0715668942\n[15,]  0.0000903667  0.0004302125 0.0000355452  1.6375342268  1.0000000000\n[16,]  0.0000000000  0.0000227529 0.0000000000  0.0680929018  0.0601659197\n[17,]  0.0000548722  0.0000588240 0.0000000000  0.1123320000  0.0084416026\n[18,]  0.9535728348  0.7421256270 0.0748409002  0.0662397445  0.0116252447\n[19,]  0.0026718912  0.7261888317 0.1267611796  0.0676552190  0.0113170554\n[20,]  0.0005431531  0.0096017096 0.1544340070  0.2960000000  0.0493877222\n[21,]  0.0000072480 -0.0000032586 0.0000000000  0.0002074509  0.0199387823\n[22,]  0.0000996095  0.0000000000 0.0000000000 -0.0001386642  0.0275791593\n[23,]  0.0002409273  0.0001752918 0.0000000000 -0.0001945789  0.0018937711\n[24,]  0.0139532270  0.0108588675 0.0012493952  0.0000827472  0.0019518068\n[25,]  0.4010171690  0.3095665279 0.0327516235 -0.0001235885  0.0020041568\n[26,]  0.0204302418  0.9997730000 0.1222550376 -0.0001052901  0.0016909975\n[27,]  0.0001340774  0.1392279331 0.0682937436 -0.0000683812  0.0006855189\n[28,]  0.0005405149  0.0151929227 0.0494363782 -0.0000328085  0.0009994182\n             U500-A        U570-A       U660-A       U740-A       U785-A\n [1,]  0.0235917813  0.0061384441 0.0004102750 0.0000773913 0.0000000000\n [2,]  0.0003203807  0.0052602974 0.0249692722 0.0058028052 0.0017509891\n [3,]  0.0001879891  0.0010441665 0.0318492556 0.0104707662 0.0030321952\n [4,]  0.0008401743  0.0043630052 0.0266911262 0.0706590000 0.0403032888\n [5,]  0.0008370850  0.0057473994 0.0038369048 0.0204155733 0.1335024236\n [6,]  0.0001610826  0.0829439007 0.0112098217 0.0017331871 0.0005784301\n [7,] -0.0000224251  0.0059834211 0.0176930000 0.0057936405 0.0019580358\n [8,]  0.0000322542  0.0010624577 0.0338630000 0.0202256964 0.0052461463\n [9,]  0.0000209065  0.0011503056 0.0027375114 0.0163066622 0.0085663395\n[10,] -0.0000309667  0.0007702062 0.0001189082 0.0096545484 0.0757493500\n[11,] -0.0001006848 -0.0000506688 0.0490000000 0.0254567771 0.0055693489\n[12,]  0.0000250980 -0.0000062958 0.0026131953 0.0249920000 0.0086412505\n[13,]  0.0005225758  0.0000000000 0.0011782568 0.0113432961 0.1187953605\n[14,]  0.0958982944  0.0067529414 0.0004387057 0.0001325069 0.0000251467\n[15,]  1.5135519893  0.1383666752 0.0169096199 0.0067897017 0.0032852189\n[16,]  1.0000000000  0.1664025713 0.0138239208 0.0029111888 0.0009098811\n[17,]  0.0131786211  1.0000000000 0.0957280252 0.0171014040 0.0055378535\n[18,]  0.0193760773  0.0026755322 1.0000000000 0.3582442013 0.1021335267\n[19,]  0.0181141497  0.0018046653 0.0021976061 1.0000000000 0.3123709707\n[20,]  0.0768280802  0.0083181330 0.0014921176 0.0211529136 1.0000000000\n[21,]  0.0330780901  0.0026794268 0.0001224306 0.0000282899 0.0000000000\n[22,]  0.4062437424  0.1580000000 0.0317046513 0.0096792138 0.0034038893\n[23,]  0.0034116521  0.1358300000 0.0334930036 0.0076754942 0.0025117156\n[24,]  0.0034847779  0.0773736550 0.2421230000 0.0818191394 0.0276059349\n[25,]  0.0034069479  0.0010978286 0.3356809153 0.0968081821 0.0300679041\n[26,]  0.0031418821  0.0004126759 0.0066743089 0.2965810109 0.1233777513\n[27,]  0.0013164596  0.0004805398 0.0001831665 0.2295597332 0.1583617556\n[28,]  0.0020677066  0.0003846433 0.0003070539 0.0304262084 0.1703870000\n             V450-A        V510-A       V570-A        V605-A       V655-A\n [1,]  0.0001126169  0.0244469354 0.0133239975  0.0017077163 0.0006419635\n [2,] -0.0000554311  0.0013903555 0.0237150000  0.1137803713 0.0791702484\n [3,] -0.0000325252  0.0008273251 0.0082851408  0.0039091379 0.1212970000\n [4,] -0.0000383267  0.0034433249 0.0352893754  0.0149409056 0.0874069877\n [5,] -0.0001771661  0.0029766981 0.0337066863  0.0126301738 0.0130122234\n [6,] -0.0000615977 -0.0000685174 0.2265353728  0.0432247652 0.0166494501\n [7,] -0.0000401281 -0.0000110945 0.0108360339  0.0412987185 0.0296288722\n [8,] -0.0000228412 -0.0000063151 0.0026596753  0.0005125683 0.0551460000\n [9,]  0.0000000000  0.0000206532 0.0029179225  0.0005357699 0.0035614167\n[10,] -0.0001104826 -0.0000305945 0.0019596098  0.0003289707 0.0001785058\n[11,]  0.0000000000  0.0000499562 0.0000000000  0.0002176366 0.0617797375\n[12,]  0.0000449063  0.0000748374 0.0000000000  0.0000143900 0.0026653617\n[13,]  0.0016213806  0.0002739234 0.0000522934 -0.0000418152 0.0014001869\n[14,]  0.0028495698  0.0005212159 0.0001460806  0.0000029026 0.0000084195\n[15,]  0.5534992576  0.0641345305 0.0074114867  0.0008045019 0.0005984415\n[16,]  0.0162614522  0.1950370000 0.0514698507  0.0069806590 0.0024811015\n[17,]  0.0006973093  0.0002682714 0.0664240134  0.0103207046 0.0038262242\n[18,]  0.0010439705  0.0003932483 0.0003280923  0.0008245414 0.0906160000\n[19,]  0.0009210165  0.0002829874 0.0001068950  0.0000071344 0.0001537055\n[20,]  0.0041824407  0.0011299998 0.0004103352  0.0000548546 0.0000664001\n[21,]  1.0000000000  0.0994629766 0.0149634907  0.0015441998 0.0004792632\n[22,]  0.1943348870  1.0000000000 0.7638979136  0.1500932160 0.0797061038\n[23,]  0.2081230000  0.0211239114 1.0000000000  0.2341494800 0.1224183543\n[24,]  0.2156768802  0.0220420896 0.2084451885  1.0000000000 0.7719972989\n[25,]  0.1939906460  0.0208337609 0.0068534717  0.0470037792 1.0000000000\n[26,]  0.1845147305  0.0203733765 0.0048240293  0.0007441674 0.0196061776\n[27,]  0.0933951231  0.0100299903 0.0042920248  0.0009033967 0.0009307708\n[28,]  0.1016800000  0.0125135507 0.0036818403  0.0007662927 0.0013439907\n            V710-A       V750-A       V785-A\n [1,] 0.0002971922 0.0001257152 0.0000583097\n [2,] 0.0366353688 0.0160234558 0.0100516039\n [3,] 0.0720700000 0.0269798099 0.0154732634\n [4,] 0.5207322077 0.2159840000 0.1798193819\n [5,] 0.0128252630 0.1001290000 0.5813326554\n [6,] 0.0071923334 0.0023822001 0.0013819583\n [7,] 0.0162058919 0.0063538387 0.0038768631\n [8,] 0.0409619444 0.0224142160 0.0110338571\n [9,] 0.0467728361 0.0188471465 0.0165369398\n[10,] 0.0005046499 0.0316497285 0.1558437227\n[11,] 0.0289495267 0.0206439009 0.0095696913\n[12,] 0.0360590000 0.0401390000 0.0263410000\n[13,] 0.0009976876 0.0329562787 0.2253836760\n[14,] 0.0000217317 0.0000170133 0.0000019936\n[15,] 0.0004410047 0.0004482531 0.0003501377\n[16,] 0.0010815226 0.0004720806 0.0002951247\n[17,] 0.0016619655 0.0005979447 0.0003571689\n[18,] 0.0515933368 0.0234699167 0.0132197184\n[19,] 0.0232060595 0.0690649491 0.0393457654\n[20,] 0.0000580466 0.0027328942 0.1055924723\n[21,] 0.0002364643 0.0001253462 0.0001236473\n[22,] 0.0461123165 0.0222024133 0.0157047765\n[23,] 0.0597285658 0.0249064740 0.0157728879\n[24,] 0.4081358956 0.2031510119 0.1297043514\n[25,] 0.5812987029 0.2329972275 0.1391381582\n[26,] 1.0000000000 0.6294465489 0.5085686408\n[27,] 0.0899398069 1.0000000000 0.8329581697\n[28,] 0.0063802415 0.2152920000 1.0000000000\n\n\nWe notice a few important details.\n\nIt is not necessary that all 3 keywords have a matrix. Nor is it necessary that the matrix be present in a specific keyword.\nThe spillover matrix is square. This is because the user will run 1 single colour control for each channel/marker they intend to acquire. In this example its 28 x 28\nThe spillover matrix is non-identity with 1’s in the diagonal!\n\nThe columns of the spillover matrix are the detectors while the rows are contribution from each fluorophore. Visualizing it as a heatmap is sometimes more helpful\n\n\n\n\n\nLooking at the figure, column 2: B610-A (detector for fluorophore BB630) has high spillover from flurophore: PE-Dazzle594 and PE.\nIn fact, when we look at the emission spectrum of the 2 dyes (PE and BB630) we see that this issue is apparent:\nThe image was created at https://www.bdbiosciences.com/en-ca/resources/bd-spectrum-viewer using the BD spectrum viewer tool.\n\n\n\n\nNow that we have a valid spillover matrix, how do we use it to correct the data?\nFirst, we would like to highlight: SPILLOVER CORRECTION IS DONE ON THE RAW (UNTRANSFORMED) DATA.\nNow to perform spillover correction (Compensation). In the cytoverse this is done by a simple call to compensate.\n\n# single call to compensate \n# spillover(cf)[[3]] indicates where the matrix to use lives\ncf_comp &lt;- compensate(\n  x = realize_view(cf),\n  spillover = spillover(cf)[[3]]\n)"
  },
  {
    "objectID": "vignettes/2_Spillover_transformation.html#transformation-and-visualization",
    "href": "vignettes/2_Spillover_transformation.html#transformation-and-visualization",
    "title": "Spillover, compensation, and Transformations",
    "section": "",
    "text": "Cytometry data tends to have a very high dynamic range. For example: the range of values in PE-Cy5-5-A channel in the FCS we have been working with is -111 2621543. The difference between cells that do not express a marker of interest and a cell that expresses variable level of marker could be order of magnitude. In such a scenario, transformation of the data can aid in better visualization and representation of the biological phenomena.\nThere are multiple approaches to transform the data in cytoverse. We will identify a few common ones as well as demonstrate how to create new transformations.\nFirst, let’s visualize why transformation is necessary. We go back to working with data from FR-FCM-Z5PC.\n\n\n\n\n\nAs we see, the variety of transformations aids in visualization and interpretation of the data.\nAlso note that the choice of transformation can and will affect the interpretation. As such, use a healthy dose of caution and follow established best practices. As well, when in doubt, talk to your collaborators.\n\n\nThe cytoverse libraries: flowWorkspace and flowCore have a multiple commonly used transformations (some are shown above) as well, one can also create a custom transformation if required.\nLet’s first use a built in transformation.\n\n# transforming using cytoverse functions\n# define a transformation\nasinh_trans &lt;- flowWorkspace::asinh_Gml2()\n\n# create a transformList that indicates which parameters to transform\nmy_trans_list &lt;- flowCore::transformList(\n  from = names(\n    markernames(cf)\n  ),\n  tfun = asinh_trans\n)\n\n# transform \ncf_transformed &lt;- flowCore::transform(\n  realize_view(cf),\n  my_trans_list\n)\n\n\n\n\n\n\nAnother option is to use a user defined transformation.\n\n# define a transformation\nmy_trans &lt;- function(x){\n  return(sqrt(abs(x)))\n}\n\n# create a transformList\nmy_trans_list &lt;- flowCore::transformList(\n  from = names(\n    markernames(cf)\n  ), \n  tfun = my_trans\n)\n\n# transform\ncf_transformed &lt;- transform(\n  realize_view(cf),\n  my_trans_list\n)\n\nWe can also transform a set of FCS files (cytoset)\n\n# read in a cytoset\ncs &lt;- load_cytoset_from_fcs(path = \"data/fcs-data/\")\n\n# extract per file compensation matrix into a list\ncompensation_list &lt;- lapply(cytoset_to_list(cs),\n                            function(x)spillover(x)[[3]])\n\n# compensate\ncs &lt;- compensate(cs, compensation_list)\n\n# using asinh_trans defined previously\nmy_trans_list &lt;- flowCore::transformList(\n  from = names(\n    markernames(cf)\n  ),\n  tfun = asinh_trans\n)\n\n# transform: this will transform the underlying data \ncs &lt;- transform(cs,my_trans_list)\n\n\n\n\n\nHow can you tell if the data have been compensated? Use your preferred plotting method to generate a scatter plot for the following markers: CADM1 and CD141 from cf and cf_comp. You may need to transform the data for appropriate visualization.\nSuppose the .fcs file does not have a spillover matrix or has an identity matrix. How confident can you be the data have been previously compensated (or not) ?"
  }
]